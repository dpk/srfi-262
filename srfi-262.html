<!DOCTYPE html>
<html lang="en">
<!--
SPDX-FileCopyrightText: 2025 Daphne Preston-Kendal
SPDX-License-Identifier: MIT
-->
  <head>
    <meta charset="utf-8">
    <title>SRFI 262: Extensible pattern matcher</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Daphne Preston-Kendal">
    <link rel="stylesheet" href="srfi-262.css"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo"></a>262: Extensible pattern matcher</h1>

<p class="author">by Daphne Preston-Kendal</p>

<h2 id="status">Status</h2>

<p style="color: red;">For editor's use only. Please do not edit
this section.</p>

<p>??? the draft/final/withdrawn status of the SRFI, information on
how to subscribe to its mailing list, and important dates in its
history. The editor will add this section.</p>

<h2 id="abstract">Abstract</h2>

<p>A pattern matching form which can operate on arbitrary Scheme
values is defined. It conforms to the following design
principles.</p>

<p>The syntax of patterns is declarative. The syntax is extensible
in the same way that Scheme’s procedural syntax is extensible by
macros.</p>

<p>For most use cases, the use of the pattern matcher should
produce code which is essentially as efficient at run time as
equivalent procedural Scheme code would be, assuming a moderately
optimizing Scheme implementation. This applies only when the
equivalent code is also equivalently correct in terms of handling
of error cases (i.e.&nbsp;including all type checks done
automatically by the pattern matcher). However, using extension
syntax should not cause this principle to be violated (provided the
extension syntax is appropriately implemented).</p>

<h2 id="toc">Table of Contents</h2>

<ol id="toc-list">
  <li><a href="#rationale" id="toc-rationale">Rationale</a>
    <ol>
      <li><a href="#rationale:early-history" id="toc-rationale:early-history">Early history</a></li>
      <li><a href="#rationale:wright-history" id="toc-rationale:wright-history">Development of the ‘Wright’ pattern
matcher</a></li>
      <li><a href="#rationale:macros" id="toc-rationale:macros">Macros as
the means of extension</a></li>
      <li><a href="#rationale:comparison" id="toc-rationale:comparison">Comparison to Wright-style pattern
matchers</a></li>
    </ol>
  </li>
  <li><a href="#issues" id="toc-issues">Issues</a></li>
  <li><a href="#specification" id="toc-specification">Specification</a>
    <ol>
      <li><a href="#spec:scheme-pattern-matching-syntax" id="toc-spec:scheme-pattern-matching-syntax">Scheme pattern matching
syntax</a></li>
      <li><a href="#spec:primitive-pattern-syntax" id="toc-spec:primitive-pattern-syntax">Built-in primitive pattern
syntax</a></li>
      <li><a href="#spec:derived-pattern-syntax" id="toc-spec:derived-pattern-syntax">Built-in derived pattern
syntax</a></li>
      <li><a href="#spec:pattern-syntax-definitions" id="toc-spec:pattern-syntax-definitions">Defining new pattern
syntax</a></li>
      <li><a href="#spec:condition" id="toc-spec:condition">Condition
type</a></li>
    </ol>
  </li>
  <li><a href="#examples" id="toc-examples">Further examples</a>
    <ol>
      <li><a href="#example:record-matching" id="toc-example:record-matching">General record matching
syntax</a></li>
      <li><a href="#example:lazy-data-structures" id="toc-example:lazy-data-structures">Lazy data structures</a></li>
      <li><a href="#example:views" id="toc-example:views">Views</a></li>
      <li><a href="#example:tree-pattern" id="toc-example:tree-pattern">Tree patterns</a></li>
    </ol>
  </li>
  <li><a href="#design-notes" id="toc-design-notes">Design notes</a>
    <ol>
      <li><a href="#design-notes:constructor-based-syntax" id="toc-design-notes:constructor-based-syntax">Constructor-based
syntax and the means of extension</a></li>
      <li><a href="#design-notes:non-linear-patterns" id="toc-design-notes:non-linear-patterns">Non-linear patterns</a></li>
      <li><a href="#design-notes:application-patterns-mv" id="toc-design-notes:application-patterns-mv">Application patterns and
multiple values</a></li>
      <li><a href="#design-notes:disjointed-variables" id="toc-design-notes:disjointed-variables">Disjointed
variables</a></li>
      <li><a href="#design-notes:coverage-checking" id="toc-design-notes:coverage-checking">Coverage checking</a></li>
    </ol>
  </li>
  <li><a href="#implementation" id="toc-implementation">Implementation</a>
    <ol>
      <li><a href="#implementation:hints" id="toc-implementation:hints">Hints for implementers</a></li>
    </ol>
  </li>
  <li><a href="#acknowledgements" id="toc-acknowledgements">Acknowledgements</a></li>
</ol>

<h2 id="synopsis">Synopsis</h2>

<p><i>This section is non-normative.</i></p>

<p>The following table lists the syntax, procedures, and condition
type made available in Scheme code by the pattern matching library.
The names of the syntactic tokens shown here are mnemonic
only&nbsp;– consult the entry for each form to see the full
grammar.</p>
<table>
  <tr>
    <th>Scheme syntax</th>
    <th>Scheme procedures</th>
    <th>Condition type</th>
  </tr>
  <tr>
    <td><code>(<a href="#entry:match">match</a> <var class=
"stx">expr</var> <var class="stx">clause</var>&nbsp;<span class=
"ell">…</span>)</code><br>
      <code>(<a href="#entry:match-values">match-values</a> <var class=
"stx">expr</var> <var class="stx">mv clause</var>&nbsp;<span class=
"ell">…</span>)</code><br>
      <code>(<a href="#entry:match-let">match-let</a> <var class=
"stx">let-like</var> <var class="stx">body</var>)</code><br>
      <code>(<a href="#entry:match-let-star">match-let*</a> <var class=
"stx">let-like</var> <var class="stx">body</var>)</code><br>
      <code>(<a href="#entry:match-let-values">match-let-values</a>
        <var class="stx">mv let-like</var> <var class=
"stx">body</var>)</code><br>
      <code>(<a href="#entry:match-let-star-values">match-let*-values</a>
        <var class="stx">mv let-like</var> <var class=
"stx">body</var>)</code><br>
      <code>(<a href="#entry:match-letrec">match-letrec</a> <var class=
"stx">let-like</var> <var class="stx">body</var>)</code><br>
      <code>(<a href="#entry:match-letrec-star">match-letrec*</a>
        <var class="stx">let-like</var> <var class=
"stx">body</var>)</code><br>
      <code>(<a href="#entry:if-match">if-match</a> <var class=
"stx">let-like</var> <var class="stx">expr<sub>1</sub></var>
        <var class="stx">expr<sub>2</sub></var>)</code><br>
      <code>(<a href="#entry:match-define">match-define</a> <var class=
"stx">pat</var> <var class="stx">expr</var>)</code><br>
      <code>(<a href="#entry:match-define-values">match-define-values</a>
        (<var class="stx">pat</var>&nbsp;<span class="ell">…</span>)
        <var class="stx">expr</var>)</code><br>
      <code>(<a href="#entry:match-lambda">match-lambda</a> <var class=
"stx">mv clause</var>&nbsp;<span class="ell">…</span>)</code><br>
      <br>
      <code>(<a href=
"#entry:define-pattern-syntax">define-pattern-syntax</a>
        <var class="stx">id</var> <var class="stx">tx
expr</var>)</code></td>
    <td><code>(<a href="#entry:match-ellipsis-p">match-ellipsis?</a>
      <var>obj</var>)</code><br>
      <br>
      <code>(<a href=
"#entry:ampmatch">make-match-violation</a>)</code><br>
      <code>(<a href="#entry:ampmatch">match-violation?</a>
        <var>obj</var>)</code></td>
    <td><code><a href="#entry:ampmatch">&amp;match</a></code></td>
  </tr>
</table>

<p>The following grammar summarizes the syntax of the
pattern-matching sublanguage, including basic and derived pattern
syntax which is included with the pattern-matching library
itself.</p>
<table class="patstxreference">
  <tr>
    <th colspan="4">Pattern syntax</th>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <th style=
"font-style: italic; font-weight: normal; text-align: left;">a
pattern ...</th>
    <th style=
"font-style: italic; font-weight: normal; text-align: left;">...
matches:</th>
  </tr>
  <tr>
    <td><var class="stx">pat</var></td>
    <td>::=</td>
    <td><code>_</code></td>
    <td><i><code>; anything</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">id</var></td>
    <td><i><code>; anything, and binds subject to id</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">self-quoting datum</var></td>
    <td><i><code>; a datum which is equal?</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code><a href="#entry:quote">'</a><var class=
"stx">datum</var></code></td>
    <td rowspan="2"><i><code>; a datum which is equal?</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:quote">quote</a> <var class=
"stx">datum</var>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:cons">cons</a> <var class=
"stx">pat<sub>car</sub></var> <var class=
"stx">pat<sub>cdr</sub></var>)</code></td>
    <td><i><code>; a pair</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:list">list</a> <var class="stx">seq
pat</var>&nbsp;<span class="ell">…</span>)</code></td>
    <td><i><code>; a list</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:cons-star">cons*</a> <var class=
"stx">seq pat</var>&nbsp;<span class="ell">…</span> <var class=
"stx">pat</var>)</code></td>
    <td><i><code>; a possibly improper list</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:lset">lset</a> <var class=
"stx">pat</var>&nbsp;<span class="ell">…</span>)</code></td>
    <td rowspan="2"><i><code>; a list with items in any
order</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:lset">lset</a> <var class=
"stx">pat</var>&nbsp;<span class="ell">…</span> <var class=
"stx">pat</var> <var class="stx">dots</var>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:vector">vector</a> <var class="stx">seq
pat</var>&nbsp;<span class="ell">…</span>)</code></td>
    <td><i><code>; a vector</code></i></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:interro">?</a> <var class=
"stx">expr</var> <var class="stx">pat</var>&nbsp;<span class=
"ell">…</span>)</code></td>
    <td><code><i>; if</i> (<var class="stx">expr</var> <var>subj</var>)
      <i>and every <var class="stx">pat</var> matches
        <var>subj</var></i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:apply">apply</a> <var class=
"stx">expr</var> <var class="stx">pat</var>&nbsp;<span class=
"ell">…</span>)</code></td>
    <td><code><i>; if values of</i> (<var class="stx">expr</var>
      <var>subj</var>) <i>match the <var class=
"stx">pat</var>s</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:and">and</a> <var class=
"stx">pat</var>&nbsp;<span class="ell">…</span>)</code></td>
    <td><code><i>; if all of the <var class="stx">pat</var>s
match</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:or">or</a> <var class=
"stx">pat</var>&nbsp;<span class="ell">…</span>)</code></td>
    <td><code><i>; if any of the <var class="stx">pat</var>s
match</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:not">not</a> <var class=
"stx">pat</var>)</code></td>
    <td><code><i>; if <var class="stx">pat</var> doesn’t
match</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:seq">seq</a> <var class="stx">iter
spec</var> <var class="stx">seq pat</var>&nbsp;<span class=
"ell">…</span>)</code></td>
    <td><code><i>; a sequence</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:seqstar">seq*</a> <var class="stx">iter
spec</var> <var class="stx">seq pat</var>&nbsp;<span class=
"ell">…</span> <var class="stx">pat</var>)</code></td>
    <td><code><i>; a possibly improper sequence</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:seqslashunordered">seq/unordered</a>
      <var class="stx">iter spec</var> <var class=
"stx">pat</var>&nbsp;<span class="ell">…</span>)</code></td>
    <td rowspan="2"><code><i>; a sequence with items in any
order</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:seqslashunordered">seq/unordered</a>
      <var class="stx">iter spec</var> <var class=
"stx">pat</var>&nbsp;<span class="ell">…</span> <var class=
"stx">pat</var> <var class="stx">dots</var>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code><a href="#entry:quasiquote">`</a><var class=
"stx">quasipat</var></code></td>
    <td rowspan="2"><code><i>; according to
quasipattern</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<a href="#entry:quasiquote">quasiquote</a> <var class=
"stx">quasipat</var>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">keyword</var> <var class=
"stx">datum</var>&nbsp;<span class="ell">…</span>)</code></td>
    <td rowspan="2"><code><i>; anything you want :-)</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">keyword</var> <var class=
"stx">datum</var>&nbsp;<span class="ell">…</span>
      .&nbsp;<var class="stx">datum</var>)</code></td>
  </tr>
  <tr>
    <td style="padding-top: 1em;"><var class="stx">seq pat</var></td>
    <td style="padding-top: 1em;">::=</td>
    <td style="padding-top: 1em;"><var class="stx">pat</var></td>
    <td style="padding-top: 1em;"><code><i>; a single item from a
sequence</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code><var class="stx">pat</var> <var class=
"stx">dotty</var></code></td>
    <td><code><i>; multiple items from a sequence</i></code></td>
  </tr>
  <tr>
    <td style="padding-top: 1em;"><var class="stx">dotty</var></td>
    <td style="padding-top: 1em;">::=</td>
    <td style="padding-top: 1em;"><var class="stx">dots</var></td>
    <td style="padding-top: 1em;"><code><i>; zero or more,
greedily</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">dots</var> <var class=
"stx">n</var>)</code></td>
    <td><code><i>; exactly that many</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">dots</var> <var class="stx">n</var>
      <var class="stx">m</var>)</code></td>
    <td><code><i>; between n and m, greedily</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">dots</var> <var class="stx">n</var>
      #t)</code></td>
    <td><code><i>; at least n, greedily</i></code></td>
  </tr>
  <tr>
    <td style="padding-top: 1em;"><var class="stx">dots</var></td>
    <td style="padding-top: 1em;">::=</td>
    <td style="padding-top: 1em;"><i>the identifier</i>
      <code>...</code></td>
    <td style="padding-top: 1em;"></td>
  </tr>
  <tr>
    <td style="padding-top: 1em;"><var class="stx">quasipat</var></td>
    <td style="padding-top: 1em;">::=</td>
    <td style="padding-top: 1em;"><var class="stx">self-quoting
datum</var></td>
    <td style="padding-top: 1em;"><code><i>; a datum which is
equal?</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">id</var></td>
    <td><code><i>; a symbol with the same name</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>()</code></td>
    <td><code><i>; the empty list</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">seq quasipat</var>&nbsp;<span class=
"ell">…</span>)</code></td>
    <td><code><i>; a proper list</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">seq quasipat</var>&nbsp;<span class=
"ell">…</span> .&nbsp;<var class="stx">quasipat</var>)</code></td>
    <td><code><i>; an improper list</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>#(<var class="stx">seq quasipat</var>&nbsp;<span class=
"ell">…</span>)</code></td>
    <td><code><i>; a vector</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>,<var class="stx">pat</var></code></td>
    <td rowspan="2"><code><i>; pattern</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(unquote <var class="stx">pat</var>)</code></td>
  </tr>
  <tr>
    <td style="padding-top: 1em;"><var class="stx">seq
quasipat</var></td>
    <td style="padding-top: 1em;">::=</td>
    <td style="padding-top: 1em;"><code><var class=
"stx">quasipat</var></code></td>
    <td style="padding-top: 1em;"><code><i>; as
quasipattern</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>,@<var class="stx">pat</var></code></td>
    <td rowspan="2"><code><i>; any number of pattern</i></code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(unquote-splicing <var class="stx">pat</var>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code><var class="stx">quasipat</var> <var class=
"stx">dotty</var></code></td>
    <td><code><i>; multiple items matching quasipattern</i></code></td>
  </tr>
</table>

<h2 id="rationale">Rationale</h2>

<p>Scheme’s lack of standard facilities for pattern matching on
general Scheme values has been criticized by functional programmers
of other languages for at least 35 years (Wadler <a href=
"#Wadler87a">1987a</a>). Generally, pattern matching enables a more
declarative style of programming closer to mathematical notation,
which is easier to reason about and which can handle error cases
without having to write explicit error-checking code.</p>
<h3 id="rationale:early-history">Early history</h3>

<p>The very early history of structural pattern matching is tied to
its use in early computer algebra systems to find mathematical
expressions and equations having particular forms. (Moses <a href=
"#Moses67">1967</a>) Pattern matching as a programming language
feature in its recognizable, modern form&nbsp;– as a means of
deconstructing records using syntax mirroring that of their
constructors&nbsp;– was first proposed by Burstall (<a href=
"#Burstall69">1969</a>), building on work by McCarthy and Painter
(<a href="#McCarthyAndPainter67">1967</a>) in the use of structural
induction to prove the correctness of a compilation technique.
Burstall proposed pattern matching as an extension to Landin
(<a href="#Landin66">1966</a>)’s proposed programming language
ISWIM, which was never actually implemented. The first
<em>implemented</em> generalized pattern matcher for a programming
language was by McBride (<a href="#McBride70">1970</a>), who
modified the Lisp&nbsp;1.5 metacircular evaluator in the process of
developing his own computer algebra system, adding the capability
to recognize structures of any kind built with <code>cons</code>
cells.</p>

<p>It was another decade before pattern matching in the style
proposed by Burstall became a part of the experimental language
Hope (Burstall, MacQueen, and Sannella <a href=
"#BurstallEtAl80">1980</a>), and subsequently a standard feature of
the descendant ML (1973; see MacQueen, Harper, and Reppy <a href=
"#MacQueenEtAl20">2020</a>) and Miranda/Haskell (1985/1990
respectively; see Hudak et al.&nbsp;<a href=
"#HudakEtAl07">2007</a>) families of programming languages. In
Lisp, declarative destructuring was added to MacLisp with the
introduction of the now-familiar <code>LET</code> form in 1978
(Steele et al.&nbsp;<a href="#SteeleEtAl74-82">1974–82</a>), but in
the initial version of Common Lisp this feature survived only in
the <code>DEFMACRO</code> argument list; <code>LET</code> was
simplified to allow basic variable binding only, as we know it
today. (Steele <a href="#Steele84">1984</a>) Early implementations
of Common Lisp reintroduced a destructuring binding construct under
the name <code>DESTRUCTURING-BIND</code>, which was adopted into
the ANSI standard. (Pitman and Moon <a href=
"#PitmanAndMoon89">1989</a>) In Scheme, a <code>destructure</code>
macro providing similar functionality was included in the T
implementation from around 1983.<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a> However, these
special forms did not allow the distinctive ML-style use of pattern
matching to test an input value against a series of successive
patterns and take action according to which pattern the value
conforms to; Lisp programmers have generally preferred the use of a
series of explicit conditionals in imperative style for this
purpose. Moreover, no RnRS report has ever standardized a
<code>destructure</code>-like syntactic form.</p>
<h3 id="rationale:wright-history">Development of the ‘Wright’
pattern matcher</h3>

<p>However, prompted by Wadler (<a href="#Wadler87a">1987a</a>)’s
remarks, early discussions of what became the R4RS <a href=
"https://groups.csail.mit.edu/mac/ftpdir/scheme-mail/HTML/rrrs-1987/threads.html#00077">
briefly included proposals for pattern matching</a>. The majority
of mailing list participants rejected pattern matching as a core
language feature, and the proposal was relegated to a planned
section of the report entitled the ‘Yellow Pages’ (containing
portable libraries). The idea was then summarily dismissed at the
June 1987 meeting of the RnRS report authors, and the Yellow Pages
were never produced.</p>

<p>Schemers have nonetheless developed a variety of pattern
matching macros using pre-hygienic and hygienic macro systems. The
most popular pattern-matching syntax was originally developed by
Bruce F.&nbsp;Duba in the mid-1980s for Scheme 84.<a href="#fn2"
class="footnote-ref" id="fnref2" role=
"doc-noteref"><sup>2</sup></a> It became more widely known after
Andrew K.&nbsp;Wright adapted, documented, and distributed it for
several other Scheme implementations from around 1993 (Wright
<a href="#Wright94">1994</a>, <a href="#Wright96">1996</a>). At
least three independent re-implementations of the same syntax have
followed: Bruce Hauman wrote a version using PLT Scheme’s
<code>syntax-case</code> which was <a href=
"https://github.com/racket/old-plt/commit/dab490d2952d614a228e53a0916fd9f71828a11e">
integrated into the main distribution in 2003</a>; Alex Shinn
implemented it in portable <code>syntax-rules</code> (Shinn
<a href="#Shinn06">2006</a>) and later made further extensions; and
Adam Nelson has implemented it in <code>syntax-rules</code> again
as part of his <a href=
"https://github.com/ar-nelson/schemepunk">Schemepunk</a> project.
This pattern matcher has been included in very many Scheme
implementations, both in the original <code>defmacro</code>-based
implementation released by Wright, and in Shinn’s later hygienic
version which has now almost universally replaced it. Under the
name of the Wright–Cartwright–Shinn (WCS) matcher,<a href="#fn3"
class="footnote-ref" id="fnref3" role=
"doc-noteref"><sup>3</sup></a> an attempt at giving it a
specification was made in <a href=
"https://srfi.schemers.org/srfi-204/srfi-204.html">SRFI&nbsp;204</a>.</p>
<!--
History of Hauman’s PLT match in the old-plt repo:
7840e99cb last commit before samth’s restructure - BAD in bisect’s terms
221d609dd commit i know for a fact doesn't have Hauman’s match - GOOD
720722d56 Flatt adds define-struct support to Wright’s orig - GOOD

dab490d29 – Hauman’s version integrated
46956e6f7 - upgraded to Hauman's version 1.9 (the last from him?)
-->

<p>Other pattern matchers in Scheme include Oleg Kiselyov’s minimal
<a href=
"https://web.archive.org/web/20210307172825/https://searchcode.com/codesearch/raw/16271210/">
<code>pmatch</code></a> in <code>syntax-rules</code> and the
<a href=
"https://web.archive.org/web/20100310162932/http://www.cs.indiana.edu/chezscheme/match/match.ss">
Chez Scheme <code>match</code> macro</a> implemented using hygienic
<code>syntax-case</code> by Dan Friedman, Erik Hilsdale, and Kent
Dybvig with contributions from others, which was described in
<a href=
"https://srfi.schemers.org/srfi-241/srfi-241.html">SRFI&nbsp;241</a>.
Another implementation worth mentioning is <a href=
"https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/code/match/p_case/0.html">
Bryan O’Sullivan’s simple <code>pattern-case</code> macro</a>,
probably the first ever pattern matcher written in portable
<code>syntax-rules</code>, which was still an optional appendix to
the R4RS at the time. None of these are nearly as widely applicable
as Wright-style pattern matchers, however: many patterns which can
be expressed in Wright’s syntax would require falling back on
writing explicit procedural destructuring code in these systems.
All of these examples are limited because their basic pattern forms
support only the built-in Scheme datum types. Even in Wright’s
pattern matcher, the use of the lexical syntax of datum types to
specify deconstruction naturally limits their applicability to
Scheme object types which lack lexical syntax. Since the widespread
adoption of standard record type systems in Scheme code, and
especially their use to implement collections types beyond the
standard Scheme lists and vectors, this has become an increasingly
pertinent problem.</p>
<h3 id="rationale:macros">Macros as the means of extension</h3>

<p>An early example which shows the potential of a less
intrinsically limited pattern matcher is <a href=
"https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/code/match/matchcmp/0.html">
Christian Queinnec’s ‘Pattern-match compiler for non-linear
second-order patterns on S-expressions’</a> (Queinnec <a href=
"#Queinnec90a">1990a</a>, <a href="#Queinnec90b">1990b</a>). In
implementations in both Scheme and Common Lisp, Queinnec
demonstrated the use of macros to extend the syntax of patterns,
similarly to how the syntax of normal Lisp code can be extended;
the core pattern language is small and not necessarily very
tractable by humans, but can be expanded into from more easily
comprehensible higher-level pattern forms. The use of macros to
define new deconstructors is an adaptation to the Scheme context of
the idea of extensible patterns, which is conventionally credited
to Wadler (<a href="#Wadler87b">1987b</a>)’s introduction of
‘views’ to the Miranda language, although McBride’s original
Lisp&nbsp;1.5 pattern matcher already featured a version of
extensible patterns.</p>

<p>Hauman’s PLT Scheme implementation of Wright’s pattern matching
interface also introduced an alternative interface, which cleanly
separated the lexical syntax of Scheme from the syntax of
deconstructors. In 2005, Sam Tobin-Hochstadt took advantage of this
to <a href=
"https://github.com/racket/old-plt/commit/4c27dde572305c616cdefec94974595209d79e8a#diff-745da84c4e98fb4840c801781de3b88bb78ad0225429a81090ab94e4433c59f5">
allow users to define new deconstructors</a> using hygienic macros,
an independent reinvention of Queinnec’s concept. This was followed
by <a href=
"https://github.com/racket/racket/commit/b7127dc9c77f55bb6f787fbb58d4ebaa940f525f">
a clean re-implementation in 2008</a> using PLT Scheme’s advanced
hygienic macro system.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> The resulting pattern
matcher&nbsp;– now part of PLT Scheme’s successor, Racket&nbsp;– is
described by its author in Tobin-Hochstadt (<a href=
"#TobinHochstadt11">2011</a>).</p>

<p>Extensibility, combined with other primitives provided by
Wright’s original pattern matcher (in particular, pattern types for
calling arbitrary Scheme predicate and accessor procedures), allows
data types defined by programmers to receive their own first-class
support by an existing pattern matcher. Racket’s <code>match</code>
inspired the design of a similar extensible pattern matcher in
Emacs Lisp called <code>pcase</code> (Monnier and Sperber <a href=
"#MonnierAndSperber20">2020</a>), as well as the Common Lisp
libraries <a href="https://github.com/m2ym/optima">Optima</a> and
<a href="https://github.com/guicho271828/trivia">Trivia</a>.</p>

<p>The pattern matcher proposed here is likewise in the lineage of,
and very closely inspired by, the Racket pattern matcher. Its main
adaptation is in the use of identifier properties (<a href=
"https://srfi.schemers.org/srfi-213/srfi-213.html">SRFI&nbsp;213</a>)
as the means of extensibility. The clean extensibility of the
pattern matcher avoids the ‘kitchen sink of features’ impression
which the featureful but non-extensible syntax of Wright-style
matchers makes: the core of the matcher is kept very small with
only a handful of basic primitives, but the matcher as a whole is
comparably powerful due to the ability to combine these primitives
into new matching abstractions.</p>
<h3 id="rationale:comparison">Comparison to Wright-style pattern
matchers</h3>

<p>Compared to Wright-style pattern matchers, the pattern matcher
proposed here is essentially equivalent in basic computational
power, omitting only the following (mis)features:</p>
<ul>
<li>

<p>The <code>get!</code> and <code>set!</code> matchers which
maintain a reference within a data structure and mutate it. This
does not compose well as a feature with the extensibility provided
by this pattern matcher, and it is probably a mistake to encourage
a matching clause to mutate the data it matched.</p>
</li>
<li>

<p>Support for ‘non-linear’ patterns in which one variable may be
named multiple times, requiring the values matched by the
respective subpatterns to be the same (in the sense of
<code>equal?</code>). This is a new feature added by Hauman and
Shinn: it was not supported by Wright’s original implementation. As
explained <a href="#design-notes:non-linear-patterns">below</a>,
this feature does not compose well with several other features
which are used more commonly and which I feel to be more
worthwhile. Such patterns also appear to be rarely used in
practice, adding significant semantic complication for little
benefit.</p>
</li>
<li>

<p>Early binding: in Shinn’s implementation, although not in any
other including Wright’s original, variables are bound
<em>during</em> the pattern matching process, not after it has
completed. This means the bindings of variables are visible during
the evaluation of subsequent expressions embedded within patterns.
This makes the semantics of matching less declarative, which has
more than merely theoretical consequences: it requires establishing
a fixed order of evaluation for all pattern types, which hinders
the application of many optimized implementation strategies for
matching. It has also required piling misfeature upon top of
misfeature: Shinn’s implementation of <code>match-letrec</code> has
to use inherently fragile Petrofsky extraction (Petrofsky <a href=
"#Petrofsky01">2001</a>).</p>
</li>
</ul>

<p>In terms of <em>expressive</em> power, however, this pattern
matcher is significantly better than Wright-style pattern matchers
because any Scheme programmer can define new types of pattern
rules. These pattern rules can, for example, provide matching
functionality for new data types, or improve or tailor the
semantics of the matchers included for Scheme’s built-in data
types. They are written much like regular macro transformers: in
particular, they can usually be entirely specified with the
familiar <code>syntax-rules</code> system, but any other means of
creating macro transformers may be used. They compose transparently
with, and appear (in both syntax and generally in semantics)
identical to the pattern rules included with the pattern matcher
itself, in the same way normal Scheme macros compose with
procedural Scheme code.</p>

<h2 id="issues">Issues</h2>
<ul>
<li>

<p>The new front end removed fenders in favour of making clause
contents bodies, but there’s still no means of explicit
fall-through to give up on a clause and continue matching. Some
possible solutions, by no means mutually exclusive:</p>
<ul>
<li>

<p>Trivia provides <a href=
"https://github.com/guicho271828/trivia/wiki/Logic-Based-Patterns#guard-pattern">
guard patterns</a> which combine a subpattern, which may bind
pattern variables, with some Lisp code, which has access to those
variables (only) and which must evaluate true for the guard pattern
to match. An entire pattern wrapped in a guard pattern would be the
equivalent of a fender, but you could also wrap an individual
subpattern in a <code>guard</code> if needed&nbsp;– which would
help bail out earlier for performance improvements (especially when
giving up early on expensive patterns like list patterns).</p>

<p>This may be moderately tricky to implement efficiently.</p>

<p>The name would need to be bikeshedded: <code>guard</code>
already means something else in Scheme.</p>
</li>
<li>

<p>Racket provides a variety of strategies for escaping from a
match clause, including both classical fenders introduced by a
<code>#:when</code> keyword, and a <code>=&gt;</code> keyword which
binds an identifier to an escape procedure (returning early) to
give up on this clause and moves on to the next one.</p>

<p><code>#:when</code> fenders can also be combined with
<code>#:do</code> fenders, in any number and order respectively.
<code>#:do</code> fenders add definitions which can be used by
subsequent <code>#:when</code> fenders.</p>
</li>
<li>

<p>Probably my preferred option right now would be a
<code>match-next-clause</code> syntax parameter (name also maybe
needs bikeshedding&nbsp;– inspired by CL
<code>CALL-NEXT-METHOD</code>). For <code>match</code> and
<code>match-values</code> (and <em>maybe</em>
<code>match-lambda</code> but not any others), invoking this syntax
parameter would continue by trying the next matching clause, but
would not return early. It’s not possible to do that without
capturing a continuation in every match clause, even ones that
don’t use <code>match-next-clause</code>, and Scheme
implementations seemingly do not optimize that away when the
continuation is never invoked.</p>

<p>Because it wouldn’t escape, it could only be used ‘safely’ in
tail position of a clause. This seems like a usability hazard. Note
that Racket actually has this (<code>failure-cont</code>), but
pushes it deep down in the documentation page so people won’t be
tempted to use it incorrectly, and will use safer
<code>=&gt;</code> escape procedures instead. With continuation
marks I think it might at least be possible to detect and warn at
run time when <code>match-next-clause</code> is used outside of
tail position&nbsp;– but I’m not sure of the cost of installing a
continuation mark, which might never be used, around every matching
clause.</p>

<p>Nonetheless, I like this, because compared to regular fenders,
it means clause bodies are still bodies, and it doesn’t require an
explicit opt in for each clause that uses it; but because it’s a
syntax parameter, the code to fall through will still only be
generated when someone actually writes a clause that uses
<code>match-next-clause</code>.</p>
</li>
</ul>
</li>
<li>

<p>Should there be a primitive besides <code>?</code> which exposes
an <code>and</code>-like pattern whose subpatterns may be tested in
any order?</p>
</li>
<li>

<p>Should there be a means to declare explicitly which predicate
identifiers used in patterns are complementary (mutually exclusive)
and which imply one another (usually because of subtyping)? This
would be useful to help implementations generate more efficient
matching code, but if the declarations are wrong it will cause
undefined behaviour.</p>
</li>
<li>

<p>Should the pattern matcher be allowed to eliminate
<code>apply</code> patterns whose subpatterns are irrefutable
(cannot affect whether a pattern matches) and which do not bind any
variables? Or should it instead depend on the dead code elimination
of the Scheme compiler to do that optimization?</p>
</li>
<li>

<p>Nested <code>quasiquote</code> patterns work the naïve way. This
is the same as in Wright’s implementation, Nelson’s implementation,
and Racket’s <code>match</code>, but not Shinn’s implementation,
where nesting works as for regular Scheme <code>quasiquote</code>.
What’s the Right Thing here? Emacs recently had <a href=
"https://debbugs.gnu.org/cgi/bugreport.cgi?bug=72328">a long
discussion about this for <code>pcase</code>.</a></p>
</li>
<li>

<p>I don’t understand what the Right Thing for
<code>unquote-splicing</code> in <code>quasiquote</code> patterns
is supposed to be. Wright’s original version and the Racket pattern
matcher both actually splice the <code>unquote-splicing</code> list
subpatterns into the surrounding list pattern, including (in the
case of Racket’s matcher) the ability to do funky things with
<code>list-no-order</code> (Racket’s equivalent of my
<code>lset</code>):</p>

<pre class=
"scheme"><code>(match '(1 2 3 4) (`(1 ,@(list 2 3) 4) #t))          <i>;=&gt; #t</i>
(match '(1 2 3 4) (`(1 ,@'(2 3) 4) #t))              <i>;=&gt; #t</i>
(match '(1 2 3 4) (`(1 ,@(list-no-order 2 3) 4) #t)) <i>;=&gt; #t</i>
(match '(1 3 2 4) (`(1 ,@(list-no-order 2 3) 4) #t)) <i>;=&gt; #t</i></code></pre>

<p>(Of these, only the equivalent of the first one&nbsp;– spelled
<code>`(1 ,@(2 3) 4)</code>&nbsp;– has a working equivalent in
Wright’s original implementation.)</p>

<p>While the composition with <code>list-no-order</code> is cool
and these deconstruction semantics do theoretically correspond to
the construction semantics of regular <code>quasiquote</code>, the
immediate utility of this is unclear to me. (I can’t find any
examples in real Racket code with GitHub Code Search, although it’s
hard to look for such examples with a pure line-based regular
expression search.) It would also be very difficult to compose
correctly and fully at least with the lower-level <code>seq</code>
family of patterns, and would be an ugly hack of some variety even
just to support the <code>list</code> family of subpatterns. (Note
that <a href=
"https://srfi.schemers.org/srfi-257/srfi-257.html">SRFI&nbsp;257</a>
also supports the Wright/Racket-style semantics, and can do so
easily because of its backtracking <code>~append</code>
pattern.)</p>

<p>By contrast, Shinn’s implementation simply treats
<code>unquote-splicing</code> as an alias for an ellipsized
pattern:</p>

<pre class=
"scheme"><code>(match '(1 (2 3) 4) (`(1 ,@(2 3) 4) #t))       <i>;=&gt; #t</i>
(match '(1 (2 3) (2 3) 4) (`(1 ,@(2 3) 4) #t)) <i>;=&gt; #t</i>
(match '(1 4) (`(1 ,@(2 3) 4) #t))             <i>;=&gt; #t</i></code></pre>

<p>This is also how this pattern is currently specified in this
pattern matcher, but the examples above are not consistent with
normal Scheme <code>quasiquote</code>.</p>

<p>The one case in which the two behaviours are reliably the same
as one another and consistent with constructive
<code>quasiquote</code> is when the subpattern of
<code>unquote-splicing</code> is a simple identifier (a pattern
variable to be bound):</p>

<pre class=
"scheme"><code>(match '(1 2) (`(1 ,@x 2) x))     <i>;=&gt; ()</i>
(match '(1 2 3) (`(1 ,@x 3) x))   <i>;=&gt; (2)</i>
(match '(1 2 3 4) (`(1 ,@x 4) x)) <i>;=&gt; (2 3)</i></code></pre>

<p>This is an expand-time error in Wright’s original
implementation, but Racket and Shinn’s implementation both agree
here. (The above examples return identical results in both.)</p>

<p>Racket’s behaviour better matches the intention of pattern
matching&nbsp;– that deconstruction mirrors construction&nbsp;– but
given the difficulties of implementation and composition, perhaps
the Right Thing for a conservative SRFI specification is simply to
allow only an identifier as the subpattern of
<code>unquote-splicing</code>.</p>
</li>
<li>

<p>I’m not a fan of the <code><var class="stx">extended
ellipsis</var></code> syntax. It should be bikeshedded a little to
be more palatable.</p>
</li>
<li>

<p>It’s not clear to me how to describe the correct semantics for
<code>seq/unordered</code> and <code>lset</code> so that they pull
out leftmost values from their input sequences when possible, given
the interaction between the order of the subpatterns and the order
of values from the input.</p>
</li>
</ul>

<h2 id="specification">Specification</h2>

<p>In the below specification text, the phrase ‘matching failure is
signalled’ means that an exception with condition types
<code>&amp;match</code> (<a href="#entry:ampmatch">see below</a>)
and <code>&amp;irritants</code> is raised. The field of the
<code>&amp;irritants</code> conditions is set to a list of the
values which were supposed to match, as specified in each
section.</p>
<h3 id="spec:scheme-pattern-matching-syntax">Scheme pattern
matching syntax</h3>
<h4 class="entry" id="entry:match"><span class=
"part-of-speech">syntax</span> <code>(match <var class="stx">input
expression</var><br>
&nbsp;&nbsp;<var class="stx">clause</var> <span class=
"ell">…</span>)</code></h4>

<p><i role="heading" aria-level="5">Syntax:</i> <code><var class=
"stx">Input expression</var></code> must be an expression.</p>

<p>Each <code><var class="stx">clause</var></code> has the form
<code>(<var class="stx">pattern</var> <var class=
"stx">body</var>)</code>.</p>

<p>A <code><var class="stx">pattern</var></code> has the following
grammar:</p>
<table class="grammar">
  <tr>
    <td><var class="stx">pattern</var></td>
    <td>::=</td>
    <td><code>_</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">identifier</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">pattern syntax</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">pattern datum</var></td>
  </tr>
</table>

<p><code><var class="stx">Pattern syntax</var></code> has the form
<code>(<var class="stx">keyword</var> <var class="stx">datum</var>
<span class="ell">…</span>)</code> or <code>(<var class=
"stx">keyword</var> <var class="stx">datum</var> <span class=
"ell">…</span> . <var class="stx">datum</var>)</code>.
<code><var class="stx">Pattern datum</var></code> is any value
which is a self-evaluating datum in normal Scheme code.</p>

<p><i role="heading" aria-level="5">Semantics:</i> The
<code><var class="stx">input expression</var></code> is evaluated
to produce a value, and <code><var class="stx">clause</var></code>s
are checked in turn from left to right, until one is found whose
<code><var class="stx">pattern</var></code>s matches the value.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> In the
literature on pattern matching, a distinction is sometimes made
between ‘top-to-bottom’ and ‘left-to-right’ pattern matching. The
former refers to the relative priority of patterns with respect to
one another, and is one of a number of possible strategies for
disambiguating between multiple patterns which match the same input
value. Under the top-to-bottom rule, which is applied here (and
here called ‘left-to-right’ in deference to the usual terminology
for Scheme and Lisp forms), disambiguation depends entirely on the
order in which patterns appear in the code. (See Hudak
et&nbsp;al.&nbsp;<a href="#HudakEtAl07">2007</a> section&nbsp;5.2
for references to other possible pattern disambiguation
strategies.) ‘Left-to-right’, in the terminology of those who make
the distinction, refers to the order in which parts of an
individual pattern are tested against parts of the input term. This
is a practical necessity in lazily evaluated languages, where a
non-matching earlier part of a term might prevent the pattern
matcher from having to examine a later part whose evaluation might
not terminate; but in strict languages such as Scheme and ML there
is little practical benefit to making a guarantee on the order in
which parts of the input value are tested. Indeed, in order to
enable more optimized compilation, this pattern matcher does
<em>not</em> make a general ‘left-to-right’ guarantee on the order
in which parts of a pattern are tested against input: only certain
types of patterns guarantee the order of testing.</p>

<p>When a <code><var class="stx">clause</var></code> with a
matching <code><var class="stx">pattern</var></code> is found, the
<code><var class="stx">body</var></code> of that clause is
evaluated and its result returned. The <code><var class=
"stx">body</var></code> is evaluated in tail position if the
<code>match</code> expression as a whole is in tail position.</p>

<p>The testing of whether <code><var class=
"stx">pattern</var></code>s match against input values is formally
defined as follows.</p>

<p>The value against which a pattern is tested is called the
subject of that pattern. Whether a pattern matches against a
particular subject is a boolean property. For example, a pattern
which is an underscore (the auxiliary syntax keyword
<code>_</code>) matches any subject, whereas a <code><var class=
"stx">pattern datum</var></code> will match if its subject is the
same (in the sense of <code>equal?</code>) as the <code><var class=
"stx">pattern datum</var></code> itself, and not match
otherwise.</p>

<p>In addition, the matching of a pattern against a subject can
cause an identifier to be bound as a variable within the evaluation
of the <code><var class="stx">body</var></code>. A pattern which is
an identifier other than <code>_</code> will, like <code>_</code>,
match any subject, but will also cause that identifier to be bound
as a variable to the subject of the pattern. Variables bound in
this way are also called pattern variables, although they are
normal Scheme variable bindings and not pattern variables in the
sense of <code>syntax-case</code>.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> The
auxiliary syntax keyword <code>else</code> has no special function
in <code>match</code> expressions. A pattern consisting only of the
<code>_</code> identifier can be used as a catch-all to handle the
case when no previous pattern matches. Attempting to use the
<code>else</code> keyword for this purpose will result in a
variable being bound within the body of the corresponding clause,
shadowing the <code>else</code> keyword and potentially causing
unexpected results when attempting to use that keyword in another
<code>cond</code> expression within the clause’s body.</p>

<p>A pattern which is an instance of <code><var class="stx">pattern
syntax</var></code> can contain subpatterns (recursively nested
instances of <code><var class="stx">pattern</var></code>) which
have different subjects to the <code><var class="stx">pattern
syntax</var></code> itself; for example, the <code><var class=
"stx">pattern syntax</var></code> might match a record instance as
its subject, while a subpattern of it might match one of the field
values of that record. The <code><var class=
"stx">keyword</var></code> of an instance of <code><var class=
"stx">pattern syntax</var></code> uniquely determines a particular
type of pattern; each such type of pattern can have its own syntax
and semantics. An instance of <code><var class="stx">pattern
syntax</var></code> usually matches its subject if some combination
of subpatterns contained within it matches a corresponding
combination of values derived from the subject, and may bind
variables for some or all of these derived values. It is a syntax
violation if the <code><var class="stx">keyword</var></code> of an
instance of <code><var class="stx">pattern syntax</var></code> is
not lexically bound to an identifier for a valid type of pattern
syntax (see <a href=
"#entry:define-pattern-syntax"><code>define-pattern-syntax</code></a>).</p>

<p>It is a syntax violation if any pattern which is an identifier
other than <code>_</code> appears more than once in any
<code><var class="stx">pattern</var></code>, including occurrences
within different subpatterns. The exception is identifiers within
subpatterns of <a href="#entry:or"><code>or</code> patterns</a>,
which must appear in each such subpattern in order to be bound as
variables within the evaluation of the <code><var class=
"stx">body</var></code> (see the description under the entry for
that pattern syntax).</p>

<p>If none of the <code><var class="stx">pattern</var></code>s
match the result of evaluating the <code><var class="stx">input
expression</var></code>, matching failure is signalled with a
one-item list containing the result of the <code><var class=
"stx">input expression</var></code> evaluation.</p>
<h4 class="entry" id="entry:match-values"><span class=
"part-of-speech">syntax</span> <code>(match-values <var class=
"stx">input expression</var><br>
&nbsp;&nbsp;<var class="stx">clause</var> <span class=
"ell">…</span>)</code></h4>

<p><i role="heading" aria-level="5">Syntax:</i> <code><var class=
"stx">Input expression</var></code> must be an expression.</p>

<p>Each <code><var class="stx">clause</var></code> has the form
<code>((<var class="stx">pattern</var> <span class="ell">…</span>)
<var class="stx">body</var>)</code>.</p>

<p><i role="heading" aria-level="5">Semantics:</i>
<code>Match-values</code> is similar to <code>match</code>, except
that the <code><var class="stx">input expression</var></code> can
evaluate to multiple values, and each value is tested against the
respective <code><var class="stx">pattern</var></code> in an
unspecified order. Each <code><var class="stx">clause</var></code>
can have a different number of <code><var class=
"stx">pattern</var></code>s; only those clauses with the correct
number of <code><var class="stx">pattern</var></code>s for the
number of values returned from evaluating the <code><var class=
"stx">input expression</var></code> will be matched against.</p>

<p>If none of the <code><var class="stx">clause</var></code>s’
<code><var class="stx">pattern</var></code>s match all of the
corresponding values, matching failure is signalled with a list of
the values produced by the <code><var class="stx">input
expression</var></code>.</p>
<h4 class="entry" id="entry:match-let"><span class=
"part-of-speech">syntax</span> <code>(match-let ((<var class=
"stx">pattern</var> <var class="stx">expression</var>) <span class=
"ell">…</span>)<br>
&nbsp;&nbsp;<var class="stx">body</var>)</code></h4>

<p><code>Match-let</code> matches the results of evaluating all the
<code><var class="stx">expression</var></code>s against the
corresponding <code><var class="stx">pattern</var></code>s. The
<code><var class="stx">pattern</var></code>s must all match the
results of the respective values obtained by this evaluation,
otherwise matching failure is signalled with a list of the values
of the <code><var class="stx">expression</var></code>s. The
evaluation of the <code><var class="stx">expression</var></code>s
takes place in an unspecified order and out of the scope of any of
the pattern variables from the <code><var class=
"stx">pattern</var></code>s; the order in which the resulting
values are tested against the corresponding patterns is also
unspecified. The <code><var class="stx">body</var></code> is then
evaluated with the pattern variables resulting from the matches
being bound to their respective subjects. The <code><var class=
"stx">body</var></code> is evaluated in tail position if the
<code>match-let</code> expression as a whole is in tail
position.</p>

<p><code>Match-let</code> could be implemented by:</p>

<pre class="scheme"><code>(define-syntax match-let
  (syntax-rules ()
    ((_ ((pat init) ...) body_0 body_1 ...)
     (match-values (values init ...)
       ((pat ...)
        body_0 body_1 ...)))))</code></pre>
<h4 class="entry" id="entry:match-let-star"><span class=
"part-of-speech">syntax</span> <code>(match-let* ((<var class=
"stx">pattern</var> <var class="stx">expression</var>) <span class=
"ell">…</span>)<br>
&nbsp;&nbsp;<var class="stx">body</var>)</code></h4>

<p><code>Match-let*</code> is like <code>match-let</code>, except
that the <code><var class="stx">expression</var></code>s are
evaluated from left to right, each with the pattern variables bound
by the <code><var class="stx">pattern</var></code>s corresponding
to the <code><var class="stx">expression</var></code>s to the left
of it in scope.</p>

<p>If any of the <code><var class="stx">pattern</var></code>s do
not match the result of evaluating the corresponding
<code><var class="stx">expression</var></code>, matching failure is
signalled with a one-item list containing the value which failed to
match the corresponding pattern.</p>

<p><code>Match-let*</code> could be implemented by:</p>

<pre class="scheme"><code>(define-syntax match-let*
  (syntax-rules ()
    ((_ () body_0 body_1 ...)
     (let ()
       body_0 body_1 ...))
    ((_ ((pat init) more ...) body_0 body_1 ...)
     (match-let ((pat init))
       (match-let* (more ...)
         body_0 body_1 ...)))))</code></pre>
<h4 class="entry" id="entry:match-let-values"><span class=
"part-of-speech">syntax</span> <code>(match-let-values
(((<var class="stx">pattern</var> <span class="ell">…</span>)
<var class="stx">expression</var>) <span class="ell">…</span>)<br>
&nbsp;&nbsp;<var class="stx">body</var>)</code></h4>

<p><code>Match-let-values</code> is like <code>match-let</code>,
except that the <code><var class="stx">expression</var></code>s can
evaluate to multiple values and must match against the
corresponding number of <code><var class=
"stx">pattern</var></code>s. The order in which the values from the
<code><var class="stx">expression</var></code>s are tested against
the <code><var class="stx">pattern</var></code>s is
unspecified.</p>

<p>If any of the groups of <code><var class=
"stx">pattern</var></code>s do not match the result of evaluating
the corresponding <code><var class="stx">expression</var></code>,
matching failure is signalled with a concatenated list of all of
the values of all of the <code><var class=
"stx">expression</var></code>s.</p>

<p><code>Match-let-values</code> could be implemented by:</p>

<pre class="scheme"><code>(define-syntax match-let-values
  (lambda (stx)
    (syntax-case stx ()
      ((_ (((pat ...) init) ...) body_0 body_1 ...)
       (with-syntax
           ((((temp ...) ...)
             (map generate-temporaries #'((pat ...) ...))))
         #'(let-values
               (((temp ...) init) ...)
             ((match-lambda
                ((pat ... ...) body_0 body_1 ...))
              temp ... ...)))))))</code></pre>
<h4 class="entry" id="entry:match-let-star-values"><span class=
"part-of-speech">syntax</span><code>(match-let*-values
(((<var class="stx">pattern</var> <span class="ell">…</span>)
<var class="stx">expression</var>) <span class="ell">…</span>)<br>
&nbsp;&nbsp;<var class="stx">body</var>)</code></h4>

<p><code>Match-let*-values</code> is like
<code>match-let-values</code>, except that the <code><var class=
"stx">expression</var></code>s are evaluated from left to right,
each with the pattern variables bound by the <code><var class=
"stx">pattern</var></code>s corresponding to the <code><var class=
"stx">expression</var></code>s to the left of it in scope. The
order in which the values from each <code><var class=
"stx">expression</var></code> is tested against the corresponding
<code><var class="stx">pattern</var></code>s is unspecified.</p>

<p>If any of the groups of <code><var class=
"stx">pattern</var></code>s do not match the result of evaluating
the corresponding <code><var class="stx">expression</var></code>,
matching failure is signalled with a list containing the values
which failed to match the corresponding patterns.</p>

<p><code>Match-let*-values</code> could be implemented by:</p>

<pre class="scheme"><code>(define-syntax match-let*-values
  (syntax-rules ()
    ((_ () body_0 body_1 ...)
     (let ()
       body_0 body_1 ...))
    ((_ (((pat ...) init) more ...) body_0 body_1 ...)
     (match-let-values (((pat ...) init))
       (match-let*-values (more ...)
         body_0 body_1 ...)))))</code></pre>
<h4 class="entry" id="entry:match-letrec"><span class=
"part-of-speech">syntax</span> <code>(match-letrec ((<var class=
"stx">pattern</var> <var class="stx">expression</var>) <span class=
"ell">…</span>)<br>
&nbsp;&nbsp;<var class="stx">body</var>)</code></h4>

<p><code>Match-letrec</code> is like <code>match-let</code>, except
that the <code><var class="stx">expression</var></code>s can
recursively refer to the variables bound by the <code><var class=
"stx">pattern</var></code>s, in the manner of standard Scheme
<code>letrec</code>. It is an error if one of the <code><var class=
"stx">expression</var></code>s tries to access or assign the value
of any of the variables during its evaluation.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> The test
suite tries to detect whether the Scheme implementation it is
running on enforces the <code>letrec</code> restriction by
signalling an error, and will automatically skip the test which
ensures it is enforced for <code>match-letrec</code> if not. This
check assumes that calling <code>eval</code> on a form that
violates the <code>letrec</code> restriction will raise some kind
of error, which is guaranteed by R6RS but not by R7RS small. If
<code>letrec</code> restriction violations do not cause an error to
be signalled but rather some other kind of (undefined) behaviour,
it may be better to comment out the test when porting an
implementation of this SRFI to a new Scheme implementation, rather
than relying on this check.</p>
<h4 class="entry" id="entry:match-letrec-star"><span class=
"part-of-speech">syntax</span> <code>(match-letrec* ((<var class=
"stx">pattern</var> <var class="stx">expression</var>) <span class=
"ell">…</span>)<br>
&nbsp;&nbsp;<var class="stx">body</var>)</code></h4>

<p><code>Match-letrec*</code> is like <code>match-let*</code>,
except that the <code><var class="stx">expression</var></code>s can
recursively refer to the variables bound by the <code><var class=
"stx">pattern</var></code>s, and can access and assign the values
of pattern variables bound in patterns to the left of their own
<code><var class="stx">pattern</var></code>, in the manner of
standard Scheme <code>letrec*</code>.</p>

<p><code>Match-letrec*</code> could be implemented by:</p>

<pre class="scheme"><code>(define-syntax match-letrec*
  (syntax-rules ()
    ((_ ((pat init) ...) body_0 body_1 ...)
     (let ()
       (match-define pat init) ...
       (let ()
         body_0 body_1 ...)))))</code></pre>
<h4 class="entry" id="entry:match-define"><span class=
"part-of-speech">syntax</span> <code>(match-define <var class=
"stx">pattern</var> <var class="stx">expression</var>)</code></h4>

<p><code>Match-define</code> defines the pattern variables
specified within the <code><var class="stx">pattern</var></code> to
the corresponding values obtained from matching the pattern against
the result of evaluating the <code><var class=
"stx">expression</var></code>. If the <code><var class=
"stx">pattern</var></code> does not match the result of evaluating
the <code><var class="stx">expression</var></code>, matching
failure is signalled with a one-item list containing the value of
the <code><var class="stx">expression</var></code>.</p>
<h4 class="entry" id="entry:match-define-values"><span class=
"part-of-speech">syntax</span> <code>(match-define-values
(<var class="stx">pattern</var> <span class="ell">…</span>)
<var class="stx">expression</var>)</code></h4>

<p><code>Match-define-values</code> is like
<code>match-define</code>, except that the <code><var class=
"stx">expression</var></code> can return multiple values, which are
matched against the corresponding <code><var class=
"stx">pattern</var></code>s. The order in which the values are
matched against the corresponding patterns is unspecified. If the
<code><var class="stx">pattern</var></code>s do not match the
values produced by evaluating the <code><var class=
"stx">expression</var></code>, matching failure is signalled with a
list of the values.</p>
<h4 class="entry" id="entry:if-match"><span class=
"part-of-speech">syntax</span> <code>(if-match ((<var class=
"stx">pattern</var> <var class="stx">expression</var>) <span class=
"ell">…</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">consequent</var><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">alternate</var>)</code></h4>

<p><i role="heading" aria-level="5">Syntax:</i> <code><var class=
"stx">Consequent</var></code> and <code><var class=
"stx">alternate</var></code> must be expressions.</p>

<p><i role="heading" aria-level="5">Semantics:</i>
<code>If-match</code> is like <code>match-let</code>, except that
if all the <code><var class="stx">pattern</var></code>s match the
values obtained by evaluating their corresponding <code><var class=
"stx">expression</var></code>s, the <code><var class=
"stx">consequent</var></code> expression is evaluated with all the
pattern variables in scope; otherwise, the <code><var class=
"stx">alternate</var></code> expression is evaluated with none of
the pattern variables in scope. The <code><var class=
"stx">consequent</var></code> or <code><var class=
"stx">alternate</var></code> is evaluated in tail position if the
<code>if-match</code> expression as a whole is in tail
position.</p>

<p><code>If-match</code> could be implemented by:</p>

<pre class="scheme"><code>(define-syntax if-match
  (lambda (stx)
    (syntax-case stx ()
      ((_ ((pat init) ...) conseq alter)
       (with-syntax ((else (make-list (length #'(pat ...)) #'_)))
         #'(match-values (values init ...)
             ((pat ...) conseq)
             (else alter)))))))</code></pre>
<h4 class="entry" id="entry:match-lambda"><span class=
"part-of-speech">syntax</span> <code>(match-lambda<br>
&nbsp;&nbsp;<var class="stx">clause</var> <span class=
"ell">…</span>)</code></h4>

<p><i role="heading" aria-level="5">Syntax:</i> Each
<code><var class="stx">clause</var></code> has the form
<code>((<var class="stx">pattern</var> <span class="ell">…</span>)
<var class="stx">body</var>)</code>.</p>

<p><i role="heading" aria-level="5">Semantics:</i>
<code>Match-lambda</code> is the fundamental pattern matching form.
It evaluates to a procedure which takes arguments according to the
number of <code><var class="stx">pattern</var></code>s in each of
the <code><var class="stx">clause</var></code>s. When the procedure
is called, it matches its arguments against each of the
<code><var class="stx">clause</var></code>s which have the same
number of <code><var class="stx">pattern</var></code>s from left to
right, testing each argument against the corresponding
<code><var class="stx">pattern</var></code>. The order in which the
arguments are matched against the <code><var class=
"stx">pattern</var></code>s of each individual clause is
unspecified. The <code><var class="stx">body</var></code> of the
leftmost matching clause is then evaluated with the pattern
variables from the pattern in scope. If no <code><var class=
"stx">clause</var></code>s have the right number of
<code><var class="stx">pattern</var></code>s, or if none of the
<code><var class="stx">pattern</var></code>s match all of the
respective arguments, matching failure is signalled with a list of
the arguments to the procedure call. The <code><var class=
"stx">body</var></code> is evaluated in tail position if the call
to the returned procedure as a whole is in tail position.</p>
<h3 id="spec:primitive-pattern-syntax">Built-in primitive pattern
syntax</h3>

<p>The following instances of <code><var class="stx">pattern
syntax</var></code> are exported by the pattern matching library.
Where the keywords are existing bindings within the base Scheme
library, the pattern syntax transformers are attached to those
bindings; otherwise, they are exported as auxiliary syntax
keywords.</p>
<h4 class="entry" id="entry:quote"><span class=
"part-of-speech">pattern syntax</span> <code>(quote <var class=
"stx">datum</var>)</code></h4>

<p>A <code>quote</code> pattern matches if its subject is the same
as the <code><var class="stx">datum</var></code> in the sense of
<code>equal?</code>, and does not match otherwise. No variable is
bound.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> For most
possible values of <code><var class="stx">datum</var></code> apart
from identifiers (symbols), list-structured forms (including the
empty list), and (on strict implementations of the R6RS) vectors, a
<code>quote</code> pattern is exactly equivalent to the unquoted
<code><var class="stx">datum</var></code> used as a pattern.</p>

<p><i role="heading" aria-level="5">Example:</i></p>

<pre class="scheme"><code>(define (null-or-something-else obj)
  (match obj
    ('() 'null)
    (_ 'something-else)))

(null-or-something-else '())  <i>;=&gt; null</i>
(null-or-something-else 'nil) <i>;=&gt; something-else</i></code></pre>
<h4 class="entry" id="entry:interro"><span class=
"part-of-speech">pattern syntax</span> <code>(? <var class=
"stx">procedure expression</var> <var class="stx">pattern</var>
<span class="ell">…</span>)</code></h4>

<p>The <code><var class="stx">procedure expression</var></code> is
evaluated to produce a procedure of one argument and one return
value. A <code>?</code> pattern tests whether applying this
procedure to its subject returns a true value. It is an error if
application of the procedure returns zero values or more than one
value. If the result of the test is false, the <code>?</code>
pattern does not match.</p>

<p>Otherwise, if there are no <code><var class=
"stx">pattern</var></code>s, the <code>?</code> pattern matches its
subject and no variable is bound. If there are any
<code><var class="stx">pattern</var></code>s, those patterns are
matched in an unspecified order against the subject and the
<code>?</code> pattern matches if all of them match the subject of
the <code>?</code> pattern. All of the variables bound by the
subpatterns are bound by the match.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> It is
unspecified when and how many times the <code><var class=
"stx">procedure expression</var></code> is evaluated, and when and
how many times the resulting procedure is called. In particular, it
may be called multiple times on the same subject. The behaviour is
undefined if the evaluation of the <code><var class="stx">procedure
expression</var></code> or the subsequent call to the procedure
assigns to the binding of any variable used in an expression within
any pattern.</p>

<p>If some of the subpatterns need to be checked before others, use
an <code>and</code> pattern to enforce the ordering.</p>

<p><i role="heading" aria-level="5">Example:</i></p>

<pre class="scheme"><code>(define (integer-or-symbol val)
  (match val
    ((? integer?) 'integer)
    ((? symbol?) 'symbol)))

(integer-or-symbol 24)  <i>;=&gt; integer</i>
(integer-or-symbol 'x)  <i>;=&gt; symbol</i>
(integer-or-symbol "x") <i>; (exception raised)</i></code></pre>
<h4 class="entry" id="entry:apply"><span class=
"part-of-speech">pattern syntax</span> <code>(apply <var class=
"stx">procedure expression</var> <var class="stx">pattern</var>
<span class="ell">…</span>)</code></h4>

<p>The <code><var class="stx">procedure expression</var></code> is
evaluated to produce a procedure of one argument and as many return
values as there are <code><var class="stx">pattern</var></code>s.
An <code>apply</code> pattern matches if and only if the values
resulting from the application of this procedure to its subject
match each of the corresponding <code><var class=
"stx">pattern</var></code>s: each value becomes the subject of the
respective subpattern. The order in which the values are tested
against the <code><var class="stx">pattern</var></code>s is
unspecified. The behaviour is undefined if application of the
procedure to the subject returns more or fewer values than the
number of <code><var class="stx">pattern</var></code>s. All of the
variables bound by all of the subpatterns are bound by the
match.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> It is
unspecified when and how many times the <code><var class=
"stx">procedure expression</var></code> is evaluated, and when and
how many times the resulting procedure is called. In particular, it
may be called multiple times on the same subject. The behaviour is
undefined if the evaluation of the <code><var class="stx">procedure
expression</var></code> or the subsequent call to the procedure
assigns to the binding of any variable used in an expression within
any pattern.</p>

<p><i role="heading" aria-level="5">Example:</i></p>

<pre class="scheme"><code>(define (fizz? n)
  (match n
    ((apply (lambda (x) (floor/ x 3)) _ 0) #t)
    (_ #f)))

(fizz? 1)  <i>;=&gt; #f</i>
(fizz? 3)  <i>;=&gt; #t</i>
(fizz? 5)  <i>;=&gt; #f</i>
(fizz? 21) <i>;=&gt; #t</i></code></pre>
<h4 class="entry" id="entry:and"><span class=
"part-of-speech">pattern syntax</span> <code>(and <var class=
"stx">pattern</var> <span class="ell">…</span>)</code></h4>

<p>An <code>and</code> pattern matches if and only if its subject
matches all of its subpatterns. All of the variables bound by all
of the subpatterns are bound by the match.</p>

<p>Unlike the subpatterns of <code>?</code> and <code>apply</code>
patterns, the subpatterns of an <code>and</code> pattern are
matched from left to right and short-circuit. It is therefore safe
for later subpatterns to depend on the matching of previous
subpatterns for type-checking purposes.</p>

<p><i role="heading" aria-level="5">Example:</i></p>

<pre class="scheme"><code>(define (fizzbuzz n)
  (match n
    ((and (? fizz?) (? buzz?)) 'fizzbuzz)
    ((? fizz?) 'fizz)
    ((? buzz?) 'buzz)
    (_ n)))

(map fizzbuzz (iota 16))
<i>;=&gt; (fizzbuzz 1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz)</i></code></pre>
<h4 class="entry" id="entry:or"><span class=
"part-of-speech">pattern syntax</span> <code>(or <var class=
"stx">pattern</var> <span class="ell">…</span>)</code></h4>

<p>An <code>or</code> pattern matches if its subject matches any of
its subpatterns. The variables that are bound to variables
correspond to the values from the leftmost subpattern which
matches. It is a syntax violation if the code associated with any
pattern refers to a variable bound by one or more, but not all of
the subpatterns of an instance of the <code>or</code> pattern
syntax.</p>

<p>The subpatterns are matched from left to right and
short-circuit. It is therefore safe for later subpatterns to depend
on the matching of previous subpatterns for type-checking
purposes.</p>

<p><i role="heading" aria-level="5">Example:</i></p>

<pre class="scheme"><code>(define (arithmetic-operation x)
  (match x
    ((list (and operator (or '+ '- '* '/))
           (and operands (? number?)) ...)
     (list operator operands))))

(arithmetic-operation '(+ 2 2))  <i>;=&gt; (+ (2 2))</i>
(arithmetic-operation '(/ 42 7)) <i>;=&gt; (/ (42 7))</i></code></pre>
<h4 class="entry" id="entry:not"><span class=
"part-of-speech">pattern syntax</span> <code>(not <var class=
"stx">pattern</var>)</code></h4>

<p>A <code>not</code> pattern matches if and only if its subject
does <em>not</em> match the given subpattern. No variable is
bound.</p>

<p><i role="heading" aria-level="5">Example:</i></p>

<pre class="scheme"><code>(define nonzero?
  (match-lambda
    (((? zero?)) #t)
    ((_) #f)))</code></pre>
<h4 class="entry" id="entry:seq"><span class=
"part-of-speech">pattern syntax</span> <code>(seq <var class=
"stx">name</var> ((<var class="stx">var</var> <var class=
"stx">init</var> <var class="stx">step</var>) <span class=
"ell">…</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">termination
condition</var><br>
&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">reference
expression</var><br>
&nbsp;&nbsp;<var class="stx">sequence pattern</var> <span class=
"ell">…</span>)</code></h4>

<p><i role="heading" aria-level="5">Syntax:</i> <code><var class=
"stx">Name</var></code> and all the <code><var class=
"stx">var</var></code>s must be identifiers. All the
<code><var class="stx">init</var></code>s, <code><var class=
"stx">step</var></code>s, and the <code><var class=
"stx">termination condition</var></code> and <code><var class=
"stx">reference expression</var></code> must be expressions.</p>

<p><code><var class="stx">Sequence pattern</var></code> has the
following grammar:</p>
<table class="grammar">
  <tr>
    <td><var class="stx">sequence pattern</var></td>
    <td>::=</td>
    <td><var class="stx">pattern</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">pattern</var> <var class="stx">extended
ellipsis</var></td>
  </tr>
</table>

<table class="grammar">
  <tr>
    <td><var class="stx">extended ellipsis</var></td>
    <td>::=</td>
    <td><var class="stx">ellipsis</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">ellipsis</var> <var class=
"stx">n</var>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">ellipsis</var> <var class=
"stx">min</var> <var class="stx">max</var>)</code></td>
  </tr>
</table>

<table class="grammar">
  <tr>
    <td><var class="stx">n</var></td>
    <td>::=</td>
    <td><i>an exact nonnegative integer literal</i></td>
  </tr>
  <tr>
    <td><var class="stx">min</var></td>
    <td>::=</td>
    <td><i>an exact nonnegative integer literal</i></td>
  </tr>
  <tr>
    <td><var class="stx">max</var></td>
    <td>::=</td>
    <td><i>an exact nonnegative integer literal greater than or equal
to</i> <var class="stx">min</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>#t</code></td>
  </tr>
</table>

<p><code><var class="stx">Ellipsis</var></code> refers to the
<code>...</code> identifier from the base Scheme library.</p>

<p><i role="heading" aria-level="5">Semantics:</i> A
<code>seq</code> pattern matches a series of values from an
iterable sequence.</p>

<p>A <code><var class="stx">sequence pattern</var></code> which is
a single <code><var class="stx">pattern</var></code> with no
ellipsis following matches one item within the sequence if the
corresponding <code><var class="stx">pattern</var></code> matches
that item. Pattern variables within the pattern are bound.</p>

<p>When a pattern is followed by an <code><var class="stx">extended
ellipsis</var></code> it matches multiple items within the
sequence, and pattern variables within the pattern list are bound
to lists of the values which matched within the input sequence. A
pattern followed by single <code><var class=
"stx">ellipsis</var></code> can match any number of input forms,
including zero. A pattern followed by <code>(<var class=
"stx">ellipsis</var> <var class="stx">n</var>)</code> must match
exactly <code><var class="stx">n</var></code> items in the input
sequence. A pattern followed by <code>(<var class=
"stx">ellipsis</var> <var class="stx">min</var> <var class=
"stx">max</var>)</code> must match at least <code><var class=
"stx">min</var></code> items within the input sequence and up to
<code><var class="stx">max</var></code> items, or an unbounded
number of items greater than or equal to <code><var class=
"stx">min</var></code> items if <code><var class=
"stx">max</var></code> is <code>#t</code>.</p>

<p>Ellipsized patterns match against input values greedily&nbsp;–
that is, they do not stop matching at the first value which matches
the pattern immediately following them; rather, each sequence
pattern attempts to consume as much input that matches itself as
possible. When multiple ellipsized patterns are included within the
list of <code><var class="stx">sequence pattern</var></code>s, the
standard leftmost priority rule applies: patterns which are further
left in the series of <code><var class="stx">sequence
pattern</var></code>s match the largest number of items in the list
they can while still satisfying the <code>seq</code> pattern as a
whole.</p>

<p>In order to access items from the sequence, the pattern matcher
establishes state variables called <code><var class=
"stx">var</var></code> by first binding them to the results of
evaluating the respective <code><var class="stx">init</var></code>
expressions in an unspecified order. At each stage of the
iteration, the pattern matcher first checks to see if the
<code><var class="stx">termination condition</var></code> evaluates
to a true value: if so, the sequence is deemed to have completed
and the <code>seq</code> pattern matches only if the complete input
sequence matches the series of <code><var class="stx">sequence
pattern</var></code>s. Otherwise, the pattern matcher evaluates the
<code><var class="stx">reference expression</var></code> and checks
the result of the evaluation against one or more of the
<code><var class="stx">sequence pattern</var></code>s as
appropriate to its own current state. Then it continues the
iteration by evaluating the <code><var class=
"stx">step</var></code> expressions, binding the results of these
evaluations to the respective <code><var class=
"stx">var</var></code>s, and beginning a new stage of the
iteration.</p>

<p>Within the evaluation of the <code><var class=
"stx">init</var></code>s, <code><var class=
"stx">step</var></code>s, the <code><var class="stx">termination
condition</var></code>, and the <code><var class="stx">reference
expression</var></code>, the identifier named by <code><var class=
"stx">name</var></code> is bound as a variable to the subject of
the <code>seq</code> pattern. Within the evaluation of the
<code><var class="stx">step</var></code>s, the <code><var class=
"stx">termination condition</var></code>, and the <code><var class=
"stx">reference expression</var></code>, the <code><var class=
"stx">var</var></code>s are bound to their respective current
values. Neither the <code><var class="stx">name</var></code> nor
the <code><var class="stx">var</var></code>s are bound as pattern
variables if the match succeeds, nor are they visible as variables
or pattern variables within the <code><var class="stx">sequence
pattern</var></code>s.</p>

<p>Note that the pattern matcher may choose to iterate over the
input sequence in multiple instances in parallel, to backtrack and
consider the same item in the input sequence multiple times, or to
terminate the iteration(s) early after concluding that the pattern
will never match. The values of the <code><var class=
"stx">var</var></code>s must encapsulate the entirety of the state
required to access items from the iterable sequence: evaluation of
the <code><var class="stx">init</var></code>, <code><var class=
"stx">step</var></code>, <code><var class="stx">reference
expression</var></code>, and <code><var class="stx">termination
condition</var></code> expressions must not mutate the internal
state of the <code><var class="stx">seq</var></code> pattern’s
subject such that a parallel evaluation of the same expressions on
the sequence would fail, and must not mutate the values of the
<code><var class="stx">var</var></code>s such that restoring
previous values in order to backtrack and re-examine an
already-examined part of the sequence would not work. As with the
expressions embedded in <code>?</code> and <code>apply</code>
patterns, it is undefined behaviour if evaluation of any of these
expressions assigns to a variable used in any expression within any
pattern.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> The
structure of an iteration with <code>seq</code> is fundamentally
similar the patterns familiar to Scheme programmers from both
‘named <code>let</code>’ and <code>do</code>. A <code>seq</code>
iteration can be thought of as expanding to</p>

<pre class="scheme"><code>(let loop ((<var class=
"stx">var</var> <var class="stx">init</var>) <span class=
"ell">…</span>)
  (if <var class="stx">termination condition</var>
      (return-match-or-fail)
      (begin
        (test-current-subpattern-for-input <var class=
"stx">reference expression</var>)
        (loop <var class="stx">step</var> <span class=
"ell">…</span>))))</code></pre>

<p class="note">or to</p>

<pre class="scheme"><code>(do ((<var class=
"stx">var</var> <var class="stx">init</var> <var class=
"stx">step</var>) <span class="ell">…</span>)
    (<var class=
"stx">termination condition</var> (return-match-or-fail))
  (test-current-subpattern-for-input <var class=
"stx">reference expression</var>))</code></pre>

<p><i role="heading" aria-level="5">Example:</i> Given a type
called a ‘vektor’ which is otherwise similar to Scheme’s built-in
vector type, the following pattern would match items from this
type.</p>

<pre class="scheme"><code>(seq vek ((idx 0 (+ idx 1)))
     (&gt;= idx (vektor-length vek))
     (vektor-ref vek idx)
  #;sequence-subpatterns...)</code></pre>

<p>See also the sample implementation for the <a href=
"#entry:vector"><code>vector</code> pattern syntax</a> and the
examples under that entry.</p>
<h4 class="entry" id="entry:seqstar"><span class=
"part-of-speech">pattern syntax</span> <code>(seq* <var class=
"stx">name</var> ((<var class="stx">var</var> <var class=
"stx">init</var> <var class="stx">step</var>) <span class=
"ell">…</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">termination
condition</var><br>
&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">reference
expression</var><br>
&nbsp;&nbsp;<var class="stx">sequence pattern</var> <span class=
"ell">…</span> <var class="stx">pattern</var>)</code></h4>

<p><code>Seq*</code> is similar to <code>seq</code>, with a
difference: after the <code><var class="stx">termination
condition</var></code> is satisfied, the <code><var class=
"stx">reference expression</var></code> (which should usually
simply be one of the <code><var class="stx">var</var></code>s) is
evaluated one more time and its result tested against the final
<code><var class="stx">pattern</var></code>; and if the final
<code><var class="stx">pattern</var></code> has been reached and
matched by some previous iteration over the sequence, and that
final test fails, the result of that previous match will be the
result of matching the whole <code>seq*</code> pattern.</p>

<p>This is the primitive for matching sequences comparable to
Scheme’s built-in lists built of pairs which do not guarantee
‘properness’, as well as for matching structures such as series of
pairs terminated by a pattern which may itself match a series of
pairs. Note, however, that due to the greediness of the ellipsis in
<code><var class="stx">sequence pattern</var></code>s, neither
<code>seq</code> nor <code>seq*</code> is well-suited to matching
sequences from streams or other potentially infinite sequences.</p>

<p><i role="heading" aria-level="5">Example:</i> Given the ‘pare’
definition from section 5.5 of the R7RS small report, the following
example shows how to match proper ‘lysts’ of ‘pares’, terminated by
Scheme’s standard empty list value.</p>

<pre class="scheme"><code>(seq* lyst ((curr list (kdr curr)))
      (not (pare? curr))
      curr
  (apply kar <i>#;subpattern</i>) <i>#;...</i>
  '())</code></pre>

<p>See also the sample implementation for the <a href=
"#entry:cons-star"><code>cons*</code></a> and <a href=
"#entry:list"><code>list</code> pattern syntax</a> and the examples
under those entries.</p>
<h4 class="entry" id="entry:seqslashunordered"><span class=
"part-of-speech">pattern syntax</span> <code>(seq/unordered
<var class="stx">name</var> ((<var class="stx">var</var>
<var class="stx">init</var> <var class="stx">step</var>)
<span class="ell">…</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">termination
condition</var><br>
&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">reference
expression</var><br>
&nbsp;&nbsp;<var class="stx">pattern</var> <span class=
"ell">…</span>)</code><br>
<span class="part-of-speech">pattern syntax</span>
<code>(seq/unordered <var class="stx">name</var> ((<var class=
"stx">var</var> <var class="stx">init</var> <var class=
"stx">step</var>) <span class="ell">…</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">termination
condition</var><br>
&nbsp;&nbsp;&nbsp;&nbsp;<var class="stx">reference
expression</var><br>
&nbsp;&nbsp;<var class="stx">pattern</var> <span class=
"ell">…</span> <var class="stx">rest pattern</var> <var class=
"stx">ellipsis</var>)</code></h4>

<p><i role="heading" aria-level="5">Syntax:</i> <code><var class=
"stx">Rest pattern</var></code>, if given, is a pattern.</p>

<p><i role="heading" aria-level="5">Semantics:</i>
<code>Seq/unordered</code> is similar to <code>seq</code>, but the
values which match the subpatterns may appear in the input sequence
in any order. Also, unlike a <code>seq</code> pattern, there can
only be one subpattern which matches more than one item from the
input sequence: it must be the last subpattern in the
<code>seq/unordered</code> pattern, and it must be unbounded.</p>

<p><code>Seq/unordered</code> patterns are useful for matching
set-like or association list-like structures which are not, or
which are only partially, inherently ordered. Because of their
intended usefulness for association lists, each <code><var class=
"stx">pattern</var></code> matches the earliest value in the input
sequence which satisfies it while still allowing all of the
<code><var class="stx">pattern</var></code>s in the sequence to
match if possible. This maintains the historical property of
association lists, whereby the leftmost value for a particular key
is considered the current value for that key, and further values
with the same key are older values which have been overwritten by
subsequent consing onto the beginning of the association list.</p>

<p>If the <code><var class="stx">rest pattern</var></code> is
given, it must match any remaining values in the list which do not
match any of the given <code><var class=
"stx">pattern</var></code>s.</p>

<p>All the pattern variables bound by all of the <code><var class=
"stx">pattern</var></code>s are bound by the match. All of the
variables bound by the <code><var class="stx">rest
pattern</var></code> are bound to lists of the corresponding values
from the input sequence, in the order they appeared in the original
input sequence.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> While it
is possible to write an implementation of
<code>seq/unordered</code> which has good asymptotic performance
for the majority of real-world use cases, in general the number of
possible orderings of subpatterns and of input values is inherently
factorial, and this will be reflected in the time and/or memory
space required for some uses. For good performance, as many of the
<code><var class="stx">pattern</var></code>s as possible should be
unambiguous with respect to one another (i.e.&nbsp;so that no value
in the sequence could ever match more than one of the
<code><var class="stx">pattern</var></code>s, even if multiple
values in the sequence could match the same pattern). The
<code><var class="stx">rest pattern</var></code> may safely be a
pattern which is ambiguous with respect to any or all of the other
subpatterns, because it is only tried when none of the other
subpatterns match.</p>

<p><i role="heading" aria-level="5">Examples:</i> See the sample
implementation for the <a href="#entry:lset"><code>lset</code>
pattern syntax</a> and the examples under that entry.</p>
<h3 id="spec:derived-pattern-syntax">Built-in derived pattern
syntax</h3>
<h4 class="entry" id="entry:cons"><span class=
"part-of-speech">pattern syntax</span> <code>(cons <var class=
"stx">pattern<sub>1</sub></var> <var class=
"stx">pattern<sub>2</sub></var>)</code></h4>

<p>A <code>cons</code> pattern matches a pair whose car matches
<code><var class="stx">pattern<sub>1</sub></var></code> and whose
cdr matches <code><var class=
"stx">pattern<sub>2</sub></var></code>. The order in which the car
and cdr are tested against the corresponding patterns is
unspecified. All pattern variables in both subpatterns are bound by
the match. If the subject of the <code>cons</code> pattern is not a
pair or either of the <code><var class="stx">pattern</var></code>s
does not match, the <code>cons</code> pattern does not match.</p>

<p><i role="heading" aria-level="5">Example:</i> The
<code>fold</code> example using <code>list-case</code> from
<a href="https://srfi.schemers.org/srfi-239/srfi-239.html">SRFI&nbsp;239</a>
can be reformulated in terms of <code>match</code> as follows.</p>

<pre class="scheme"><code>(define fold
  (lambda (proc seed ls)
    (let f ((acc seed) (ls ls))
      (match ls
        ((cons h t) (f (proc h acc) t))
        ('() acc)
        (_ (assertion-violation 'fold "not a list" ls))))))</code></pre>

<p><code>Cons</code> could be implemented as pattern syntax by:</p>

<pre class="scheme"><code>(define-pattern-syntax cons
  (syntax-rules ()
    ((_ car-pat cdr-pat)
     (? pair?
        (apply car car-pat)
        (apply cdr cdr-pat)))))</code></pre>
<h4 class="entry" id="entry:list"><span class=
"part-of-speech">pattern syntax</span> <code>(list <var class=
"stx">sequence pattern</var> <span class=
"ell">…</span>)</code></h4>

<p>A <code>list</code> pattern matches a proper list of Scheme
values whose elements match the <code><var class="stx">sequence
pattern</var></code>s.</p>

<p><i role="heading" aria-level="5">Examples:</i></p>

<pre class="scheme"><code>(match '(1 2 3)
  ((list a b c) (+ a b c))) <i>;=&gt; 6</i>

(match '(1 2 3 4)
  ((list a b c) (+ a b c))) <i>; (exception raised)</i>

(match '(1 2 3 . 4)
  ((list a b c) (+ a b c))) <i>; (exception raised)</i>

(match '(tagged 1 x 2 y)
  ((list 'tagged n ...) n)) <i>;=&gt; (1 x 2 y)</i>

(match '(x y z 10 11 12)
  ((list (and (? symbol?) syms) ...
         (and (? number?) nums) ...)
   (values syms nums))) <i>;=&gt; (x y z) (1 2 3)</i>

(match '(1 2 3 split 4 5 6)
  ((list before ... 'split after ...)
   (values before after))) <i>; (1 2 3) (4 5 6)</i>

(match '(1 2 split 3 4 split 5 6)
  ((list before ... 'split after ...)
   (values before after))) <i>; (1 2 split 3 4) (5 6)</i></code></pre>

<p><code>List</code> could be implemented as pattern syntax by:</p>

<pre class="scheme"><code>(define-pattern-syntax list
  (syntax-rules ()
    ((_ subpat ...)
     (cons* subpat ... '()))))</code></pre>
<h4 class="entry" id="entry:cons-star"><span class=
"part-of-speech">pattern syntax</span> <code>(cons* <var class=
"stx">sequence pattern</var> <span class="ell">…</span> <var class=
"stx">pattern</var>)</code></h4>

<p>A <code>cons*</code> pattern matches a proper or improper list
of Scheme values. The final <code><var class=
"stx">pattern</var></code> matches the tail of the list after all
<code><var class="stx">sequence pattern</var></code>s. If the tail
<code><var class="stx">pattern</var></code> matches pairs, it will
match the shortest possible proper or improper list; the
<code><var class="stx">sequence pattern</var></code>s may be tested
for matching against some items within the pairs which actually
ultimately form part of the match for the <code><var class=
"stx">pattern</var></code>s.</p>

<p><i role="heading" aria-level="5">Examples:</i></p>

<pre class="scheme"><code>(match '(1 2 3 . 4)
  ((cons* a b c d) (+ a b c d))) <i>;=&gt; 10</i>

(match '(1 2 3 4 . 5)
  ((cons* x ... y) (cons y x))) <i>;=&gt; (5 1 2 3 4)</i></code></pre>

<p><code>Cons*</code> could be implemented as pattern syntax
by:</p>

<pre class="scheme"><code>(define-pattern-syntax cons*
  (syntax-rules ()
    ((_ seq-pat ... tail-pat)
     (seq* ls ((curr ls (cdr curr)))
           (not (pair? curr))
           curr
       (apply car seq-pat) ...
       tail-pat))))</code></pre>
<h4 class="entry" id="entry:vector"><span class=
"part-of-speech">pattern syntax</span> <code>(vector <var class=
"stx">sequence pattern</var> <span class=
"ell">…</span>)</code></h4>

<p>A <code>vector</code> pattern matches a vector whose elements
match the <code><var class="stx">sequence
pattern</var></code>s.</p>

<p><i role="heading" aria-level="5">Examples:</i></p>

<pre class="scheme"><code>(match '#(1 2 3)
  ((vector a b c) (list a b c))) <i>;=&gt; (1 2 3)</i>

(match '#(record 1 x 2 y)
  ((vector 'record n ...) n)) <i>;=&gt; (1 x 2 y)</i></code></pre>

<p><code>Vector</code> could be implemented as pattern syntax
by:</p>

<pre class="scheme"><code>(define-pattern-syntax vector
  (syntax-rules ()
    ((_ subpat ...)
     (and (? vector?)
          (seq vec ((idx 0 (+ idx 1)))
               (&gt;= idx (vector-length vec))
               (vector-ref vec idx)
            subpat ...)))))</code></pre>
<h4 class="entry" id="entry:quasiquote"><span class=
"part-of-speech">pattern syntax</span> <code>(quasiquote
<var class="stx">quasipattern</var>)</code></h4>

<p><i role="heading" aria-level="5">Syntax:</i> <code><var class=
"stx">Quasipattern</var></code> has the following grammar:</p>
<table class="grammar">
  <tr>
    <td><var class="stx">quasipattern</var></td>
    <td>::=</td>
    <td><var class="stx">identifier</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">pattern datum</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">sequence
quasipattern</var>&nbsp;<span class="ell">…</span>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(<var class="stx">sequence
quasipattern</var>&nbsp;<span class="ell">…</span> . <var class=
"stx">quasipattern</var>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>#(<var class="stx">sequence
quasipattern</var>&nbsp;<span class="ell">…</span>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(unquote <var class="stx">pattern</var>)</code></td>
  </tr>
</table>

<table class="grammar">
  <tr>
    <td><var class="stx">sequence quasipattern</var></td>
    <td>::=</td>
    <td><var class="stx">quasipattern</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><var class="stx">quasipattern</var> <var class="stx">extended
ellipsis</var></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(unquote <var class="stx">pattern</var>&nbsp;<span class=
"ell">…</span>)</code></td>
  </tr>
  <tr>
    <td></td>
    <td>|</td>
    <td><code>(unquote-splicing <var class=
"stx">pattern</var>&nbsp;<span class="ell">…</span>)</code></td>
  </tr>
</table>

<p><i role="heading" aria-level="5">Semantics:</i> Within a
<code><var class="stx">quasipattern</var></code>, all
<code><var class="stx">identifier</var></code>s match symbols
except outside of unquoted <code>(unquote <var class=
"stx">pattern</var>)</code> escapes. In addition, list-structured
<code><var class="stx">quasipattern</var></code>s match literal
proper or improper lists rather than being interpreted as
<code><var class="stx">pattern syntax</var></code>. Within a list-
or vector-structured <code><var class=
"stx">quasipattern</var></code>, <code>unquote-splicing</code> or a
following <code><var class="stx">ellipsis</var></code> can be used
to match multiple items from within the list or vector, analogously
to a <code><var class="stx">sequence pattern</var></code>.</p>
<h4 class="entry" id="entry:lset"><span class=
"part-of-speech">pattern syntax</span> <code>(lset <var class=
"stx">pattern</var> <span class="ell">…</span>)</code><br>
<span class="part-of-speech">pattern syntax</span> <code>(lset
<var class="stx">pattern</var> <span class="ell">…</span>
<var class="stx">rest pattern</var> <var class=
"stx">ellipsis</var>)</code></h4>

<p>An <code>lset</code> pattern matches a proper list of Scheme
values, testing that items which match the <code><var class=
"stx">pattern</var></code>s appear in any order within its subject.
If the <code><var class="stx">rest pattern</var></code> is given,
it must match any remaining values in the list which do not match
the set of <code><var class="stx">pattern</var></code>s.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> See the
note on performance under <code>seq/unordered</code>.</p>

<p><i role="heading" aria-level="5">Examples:</i></p>

<pre class="scheme"><code>(match '(1 2 3)
  ((lset (? even? x)
         (? odd? y)
         (? odd? z))
   (list x y z))) <i>;=&gt; (2 1 3)</i>

(match '((a . 1) (b . 2) (c . 3))
  ((lset (cons 'b val) _ ...) val)) <i>;=&gt; 2</i>

(match '(1 x 2 y)
  ((lset (? symbol? s) more ...)
   (values s more))) <i>;=&gt; x (1 2 y)</i></code></pre>

<p><code>Lset</code> could be implemented by:</p>

<pre class="scheme"><code>(define-syntax lset (syntax-rules ()))

(define-pattern-syntax lset
  (syntax-rules ()
    ((_ subpat ...)
     (and (? list?)
          (seq/unordered ls ((more ls (cdr more)))
                         (null? more)
                         (car more)
            subpat ...)))))</code></pre>
<h3 id="spec:pattern-syntax-definitions">Defining new pattern
syntax</h3>
<h4 class="entry" id="entry:define-pattern-syntax"><span class=
"part-of-speech">syntax</span> <code>(define-pattern-syntax
<var class="stx">identifier</var> <var class="stx">transformer
expression</var>)</code></h4>

<p><i role="heading" aria-level="5">Syntax:</i> <code><var class=
"stx">Identifier</var></code> must be an identifier which already
has some kind of binding associated with it. <code><var class=
"stx">Transformer expression</var></code> is as for the right hand
side of the base Scheme <code>define-syntax</code>.</p>

<p><i role="heading" aria-level="5">Semantics:</i> Associates the
transformer resulting from evaluating the <code><var class=
"stx">transformer expression</var></code> with the
<code><var class="stx">identifier</var></code>. When a
<code><var class="stx">pattern syntax</var></code> use whose
<code><var class="stx">keyword</var></code> is the given
<code><var class="stx">identifier</var></code> appears within a
<code><var class="stx">pattern</var></code>, the matcher will
replace that pattern with the result of calling the transformer on
the use of pattern syntax. This process is analogous to the normal
process of Scheme macro expansion.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> The
sample implementation only supports transformer procedures as the
right-hand side of <code>define-pattern-syntax</code>. Since it is
unlikely that anyone will want to use a variable transformer as a
pattern syntax transformer, and all known syntax object-based
expander implementations return an ordinary transformer procedure
from <code>syntax-rules</code> expressions (albeit this is not
guaranteed by the R6RS specification, though it is guaranteed by
the current draft of R7RS Large), this is not a problem in practice
for any known expander, but future adaptations of the sample
implementation may need to specially treat transformer types which
are not procedures of the signature Syntax&nbsp;→&nbsp;Syntax.</p>

<p>The behaviour of pattern syntax associations by
<code>define-pattern-syntax</code> is equivalent to the behaviour
of an identifier property. For example, it is possible to define
pattern syntax on an identifier which is not exported from the
library where it is defined, in which case the pattern syntax will
only be visible inside the library. It is also possible to locally
re-define the pattern syntax associated with imported bindings
within a library, and this will not affect uses of the pattern
syntax in other libraries. Likewise, if pattern syntax is defined
or redefined within a local-binding context, the pattern syntax
will only be visible within that context. The pattern syntax
associated with an identifier is exported and made available under
that identifier when the identifier itself is exported from a
library. It is an error to import an identifier twice with the same
binding from different libraries if they have different pattern
syntax associated with them.</p>

<p><i role="heading" aria-level="5">Examples:</i> See the examples
under the entries in the section on derived pattern syntax.</p>

<p>In general, pattern syntax specialized for matching instances of
a record type can be expressed as a combination with
<code>and</code> of a <code>?</code> pattern for that record type’s
predicate and <code>apply</code> patterns for each of that record
type’s field accessor procedures. The following definition of a
two-dimensional point record type will be used as an example.</p>

<pre class="scheme"><code>(define-record-type point
  (make-point x y) point?
  (x point-x)
  (y point-y))</code></pre>

<p>Given this definition, a pattern to match instances of
<code>point</code> can be expressed directly as follows:</p>

<pre class="scheme"><code>(match my-location
  ((? point?
      (apply point-x my-location-x)
      (apply point-y my-location-y))
   (show #t
     "I am at X coord: " my-location-x ", Y coord:" my-location-y)))</code></pre>

<p>But this can be more concisely expressed by defining pattern
syntax to expand into this form of pattern, as follows:</p>

<pre class="scheme"><code>(define-pattern-syntax point
  (syntax-rules ()
    ((_ x-pat y-pat)
     (? point?
        (apply point-x x-pat)
        (apply point-y y-pat)))))</code></pre>

<p>allowing the previous example to be rewritten more concisely and
more expressively:</p>

<pre class="scheme"><code>(match my-location
  ((point my-location-x my-location-y)
   (show #t
     "I am at X coord: " my-location-x ", Y coord:" my-location-y)))</code></pre>

<p>This new pattern can then of course be composed with other
pattern syntax:</p>

<pre class="scheme"><code>(define (point-quadrant pt)
  (match pt
    ((point (? positive?) (? positive?)) 'upper-right)
    ((point (? positive?) (? negative?)) 'lower-right)
    ((point (? negative?) (? positive?)) 'upper-left)
    ((point (? negative?) (? negative?)) 'lower-left)
    ((or (point (? zero?) _)
         (point _ (? zero?)))
     (assertion-violation 'point-quadrant "point has a zero coordinate" pt))))</code></pre>
<h5 id="non-normative-conventions-for-pattern-syntax-identifiers">
Non-normative: Conventions for pattern syntax identifiers</h5>

<p>Record types in Scheme are used as part of the public interface
of libraries in at least two ways.</p>

<p>The first is to create true records, representing data about
some entity that is relevant to the program’s domain of operation.
In this case I suggest that the record type name (in the sense of
R6RS and R7RS) should be used as the name of the pattern syntax.
The following <code>define-record-type+pattern-syntax</code> macro
defines both a record type (in R7RS small style) and pattern syntax
for that record type.</p>

<pre class=
"scheme"><code>(define-syntax define-record-type+pattern-syntax
  (syntax-rules ()
    ((_ name constructor-spec predicate
        (field-name accessor . maybe-setter) ...)
     (begin
       (define-record-type name constructor-spec predicate
                           (field-name accessor . maybe-setter) ...)
       (define-pattern-syntax name
         (syntax-rules ()
           ((_ field-name ...)
            (? predicate
               (apply accessor field-name) ...))))))))</code></pre>

<p>Example usage:</p>

<pre class=
"scheme"><code>(define-record-type+pattern-syntax measure
  (make-measure magnitude unit) measure?
  (magnitude measure-magnitude)
  (unit measure-unit))

(define (fff-&gt;si m)
  (match m
    ((measure n 'furlong)
     (make-measure (* n #e201.168) 'metre))
    ((measure n 'firkin)
     (make-measure (* n #e40.8233133) 'kilogram))
    ((measure n 'fortnight)
     (make-measure (* n 1209600) 'second))))</code></pre>

<p>Further, it may be desirable, at least in some cases, to be able
to use a kind of ‘keyword subpattern’ to match the fields of
records. The following example extends the above to allow this.</p>

<pre class=
"scheme"><code>(define-syntax define-record-type+pattern-syntax/keyword
  (syntax-rules ::: ()
    ((_ name constructor-spec predicate
        (field-name accessor . maybe-setter) :::)
     (begin
       (define-record-type name constructor-spec predicate
                           (field-name accessor . maybe-setter) :::)
       (define-pattern-syntax name
         (lambda (stx)
           (syntax-case stx ()
             ((_ subpat ...)
              #`(? predicate
                   #,@(map
                       (lambda (subpat)
                         (syntax-case subpat (accessor :::)
                           ((accessor field-pat)
                            #'(apply accessor field-pat)) :::))
                       #'(subpat ...)))))))))))</code></pre>

<p>Example usage:</p>

<pre class=
"scheme"><code>(define-record-type+pattern-syntax/keyword journal
  (make-journal title abbreviation) journal?
  (title journal-title)
  (abbreviation journal-abbreviation))

(define journals
  (list (make-journal "Journal of Indo-European Studies"
                      "JIES")
        (make-journal "Zeitschrift für vergleichende Sprachforschung"
                      "KZ")
        (make-journal "Notes and Queries"
                      "NQ")))

(define journal-abbreviations
  (match journals
    ((list (journal (journal-abbreviation abbr)) ...)
     abbr)))

<i>;; journal-abbreviations =&gt; ("JIES" "KZ" "NQ")</i></code></pre>

<p>The other main use of record types in Scheme is simply as a
means of creating a disjoint type in order to represent some kind
of composite data structure. Recall the existing Scheme convention
that the name of the data type itself denotes a constructor which
pre-fills a data structure with values passed to the constructor
(as opposed to constructors whose name starts with
<code>make-</code>, which merely pre-initialize the structure with
a certain number of values). The name of this constructor procedure
should (as in the examples <code>list</code>, <code>cons</code>,
<code>vector</code>, etc.) be associated with pattern syntax which
deconstructs the input using syntax essentially similar to that
accepted by the constructor procedure itself to maximize symmetry
between construction and deconstruction. In some cases it may be
necessary to define multiple types of pattern syntax for one data
type to match against input in different styles (as in the example
of <code>list</code> and <code>cons</code>). It is not possible to
give a general example as every data structure’s needs may be
different.</p>

<p>Programmers defining pattern syntax for record types which do
not fall cleanly into these categories, or some other form of
pattern syntax entirely, can simply devise their own
conventions.</p>
<h5 id="non-normative:robustness">Non-normative: Robustness of
pattern definitions</h5>

<p>In general, evaluation of expressions in pattern syntax (the
<code><var class="stx">procedure expression</var></code>s of
<code>?</code> and <code>apply</code> patterns as well as calls to
the resulting procedures, and the expressions used in a
<code>seq</code> pattern) should have well-defined behaviour, and
should never cause an error to be signalled during matching. A
pattern should either match its subject or not. The evaluation of
expressions which may either cause an error to be signalled or
cause undefined behaviour should be guarded by a predicate using a
<code>?</code> pattern and the left-to-right guarantee of the
<code>and</code> pattern.</p>

<p>For example, the following would not be a good implementation of
a <code>cons</code> pattern:</p>

<pre class="scheme"><code>(define-pattern-syntax bad-cons
  (syntax-rules ()
    ((_ car-pat cdr-pat)
     (and (apply car car-pat)
          (apply cdr cdr-pat)))))</code></pre>

<p>This pattern will misbehave if the pattern matcher attempts to
call it on a subject which is not a pair. If the <code>match</code>
user intends for an error to be signalled on non-pair input, they
should decide this for themselves by allowing the matcher to run
out of patterns or providing an explicit case for subjects which
are not pairs. The above pattern definition makes uses such as the
following impossible, because the pair procedures <code>car</code>
and <code>cdr</code> will signal an error and cause the whole
<code>match</code> expression to fail before the cases for the
empty list and other possible inputs are tried.</p>

<pre class="scheme"><code>(match x
  ((bad-cons a b) 'make-progress)
  ('() 'end-of-proper-list)
  (_ 'improper-list))</code></pre>

<p>Signalling an error during expansion of a pattern if the pattern
use does not conform to the syntax of the pattern is of course
normal and encouraged.</p>
<h4 class="entry" id="entry:match-ellipsis-p"><span class=
"part-of-speech">procedure</span> <code>(match-ellipsis?
<var>obj</var>)</code></h4>

<p>Returns <code>#t</code> if <code><var>obj</var></code> is a
syntax object representing an <code><var class="stx">extended
ellipsis</var></code> as used in a <code><var class="stx">sequence
pattern</var></code>; raises a syntax violation if
<code><var>obj</var></code> is a syntax object which uses the
<code>...</code> identifier incorrectly for use in a
<code><var class="stx">sequence pattern</var></code>; or returns
<code>#f</code> otherwise.</p>

<p><i role="heading" aria-level="5">Rationale:</i> Pattern syntax
definitions which build upon <code>seq</code> and its relatives may
need to pre-process the series of subpattern forms they are given,
for example if their own syntax for subpatterns is something other
than a simple <code><var class="stx">pattern</var></code>. In this
case, the syntax definition will need to pre-process the series of
subpatterns it is given to convert its own special syntax into the
syntax of <code><var class="stx">seq</var></code>, but in doing so
should generally treat the <code><var class="stx">extended
ellipsis</var></code> in the series of input subforms specially,
passing it directly through to <code>seq</code>.</p>

<p>Such pattern definitions should use <code>match-ellipsis?</code>
to detect the <code><var class="stx">extended
ellipsis</var></code>, since the syntax and semantics of
<code><var class="stx">extended ellipsis</var></code> may be
extended in the future.</p>

<p><i role="heading" aria-level="5">Example:</i> The example of
matching a ‘lyst’ of ‘pares’ from above can be expressed as a
pattern syntax definition as follows.</p>

<pre class="scheme"><code>(define-pattern-syntax lyst
  (lambda (stx)
    (syntax-case stx ()
      ((_ subpat ...)
       (with-syntax (((seq-subpat ...)
                      (map
                       (lambda (subpat)
                         (if (match-ellipsis? subpat)
                             subpat
                             #`(apply kar #,subpat)))
                       #'(subpat ...))))
       #'(seq* ls ((curr ls (kdr curr)))
               (not (pare? curr))
               curr
           seq-subpat ... '()))))))</code></pre>
<h3 id="spec:condition">Condition type</h3>
<h4 class="entry" id="entry:ampmatch"><span class=
"part-of-speech">condition type</span> <code>&amp;match</code><br>
<span class="part-of-speech">procedure</span>
<code>(make-match-violation)</code><br>
<span class="part-of-speech">procedure</span>
<code>(match-violation? <var>obj</var>)</code></h4>

<p>This condition type is a subtype of the standard condition type
<code>&amp;assertion</code> and has no fields. It could be defined
by</p>

<pre class=
"scheme"><code>(define-condition-type &amp;match &amp;assertion
  make-match-violation match-violation?)</code></pre>

<h2 id="examples">Further examples</h2>
<h3 id="example:record-matching">General record matching
syntax</h3>

<p>This pattern matcher does not include by default a pattern type
which can match records by their field values without defining new
pattern syntax for their record type. This feature is not portable
to systems without a record procedural/inspection layer, and may
have less than ideal run-time performance in any case. Furthermore,
the use of such pattern types can be regarded as an anti-pattern,
because they inherently make the field structure of records, which
ought to be regarded as an implementation detail of the record
type, into part of their public interface (see <a href=
"https://srfi.schemers.org/srfi-256/srfi-256.html">SRFI 256</a>).
It is generally preferable to define specialized pattern syntax for
each record type, <a href="#entry:define-pattern-syntax">as
demonstrated above</a>.</p>

<p>On Schemes with an R6RS-compatible record system, the
<code>$</code> pattern of Wright-style matching libraries can be
brought back roughly as follows:</p>

<pre class=
"scheme"><code>(define-syntax record (syntax-rules ())) <i>; dummy binding to hold only</i>
                                         <i>; pattern syntax</i>

(define-pattern-syntax record
  (lambda (stx)
    (syntax-case stx ()
      ((_ type field-pat ...)
       (with-syntax ((rtd #'(record-type-descriptor type))
                     ((field-n ...) (iota (length #'(field-pat ...)))))
         #'(? (record-predicate rtd)
              (apply (record-accessor rtd field-n) field-pat) ...))))))</code></pre>

<p>Example usage:</p>

<pre class="scheme"><code>(define-record-type point (fields x y))

(define (distance-from-origin pt)
  (match pt
    ((record point x-pos y-pos)
     (sqrt (+ (* x-pos x-pos)
              (* y-pos y-pos))))))

(distance-from-origin (make-point 3 4)) <i>;=&gt; 5</i>
(distance-from-origin (make-point 4 5)) <i>;=&gt; 6.4031242...</i></code></pre>

<p>Aside from the general design issue noted above, the run-time
efficiency of this particular pattern syntax is not as good as if
the corresponding type had been given its own pattern syntax
directly, as e.g.&nbsp;in the
<code>define-record-type+pattern-syntax</code> example above,
because of the need to invoke record type inspection procedures at
run time. A means of expand-time record type inspection, such as
that proposed in <a href=
"https://srfi.schemers.org/srfi-136/srfi-136.html">SRFI 136</a>,
could reduce or eliminate this overhead.</p>

<p>The <code>record</code> pattern example also only allows
matching fields from one layer of a type hierarchy, following the
design of the R6RS record system. Fields from multiple layers have
to be extracted by addressing each layer specifically:</p>

<pre class=
"scheme"><code>(define-record-type point-3d (parent point) (fields z))

(define (point-3d-translate pt dx dy dz)
  (match pt
    ((and (record point x y)
          (record point-3d z))
     (make-point-3d (+ x dx)
                    (+ y dy)
                    (+ z dz)))))</code></pre>

<p>This somewhat reduces the exposure of the field structure of
each individual level of the type hierarchy, as does the ability to
omit field patterns from the right of the <code>record</code>
pattern (so the implementer of record types can still safely add
new fields at the right). Still, it is better in general to
separate the definition of a record type from the definition of its
matching interface.</p>
<h3 id="example:lazy-data-structures">Lazy data structures</h3>

<p>As noted in the <a href="#entry:match">entry on
<code>match</code>,</a> a pattern matcher designed for a
strictly-evaluated language with strict data structures (such as
this one) can, in many contexts, safely use any order for testing
patterns and subpatterns in order to most efficiently rule out
non-matching clauses and select the appropriate matching clause.
However, Scheme’s first-class procedures and macro system also
provide the means to implement lazy data structures such as the
streams of <a href=
"https://srfi.schemers.org/srfi-41/srfi-41.html">SRFI&nbsp;41</a>.
For data structures like these, it is preferable to require
left-to-right pattern matching so that the pattern matcher will not
look ‘too far ahead’ in a sequence to a point where evaluation will
diverge or signal an error.</p>

<p>Achieving this for patterns matching individual instances is
simple, though: pattern syntax for a lazy record or data structure
must only use the <code>and</code> pattern with its guarantee of
left-to-right matching; avoid the subpattern functionality of the
<code>?</code> primitive which does not make any such guarantee; be
careful about its use of multiple subpatterns of the
<code>apply</code> primitive; and ensure all values are forced as
soon as they are accessed by <code>apply</code> patterns. The
functionality of the <code>stream-match</code> form of SRFI&nbsp;41
can be simulated with pattern syntax for the
<code>stream-cons</code>, <code>stream-null</code>, and
<code>stream</code> constructors, plus (for convenience) a new
<code>stream-cons*</code> constructor, as follows:</p>

<pre class="scheme"><code>(define-pattern-syntax stream-cons
  (syntax-rules ()
    ((_ car-pat cdr-pat)
     (and (? stream-pair?)
          (apply stream-car car-pat)
          (apply stream-cdr cdr-pat)))))

(define-pattern-syntax stream-null
  (syntax-rules ()
    ((_) (? stream-null?))))

(define-syntax stream-cons*
  (syntax-rules ()
    ((_ elt) elt)
    ((_ elt more ...)
     (stream-cons elt (stream-cons* more ...)))))
(define-pattern-syntax stream-cons*
  (syntax-rules ()
    ((_ pat) pat)
    ((_ pat more ...)
     (stream-cons pat (stream-cons* more ...)))))

(define-pattern-syntax stream
  (syntax-rules ()
    ((_ pat ...)
     (stream-cons* pat ... (stream-null)))))</code></pre>

<p>A disadvantage is that the deconstructor for the empty stream
must be spelled <code>(stream-null)</code>, while the constructor
is spelled <code>stream-null</code>. This could be fixed by a
corresponding change in the syntax of SRFI&nbsp;41, or simply by
making the empty stream object the same as the standard Scheme
empty list object and eliminating the <code>stream-null</code>
constructor and deconstructor entirely.</p>

<pre class="scheme"><code>(define (len strm)
  (match strm
    ((stream-null) 0)
    ((stream-cons head tail) (+ 1 (len tail)))))
<!-- TODO: add the x/y equal? checking example when we have a fender/fallthrough solution -->
(define-stream (stream-merge lt? . strms)
  (define-stream (merge xs ys)
    (match-values (values xs ys)
      (((stream-null) ys) ys)
      ((xs (stream-null)) xs)
      (((stream-cons x xs*) (stream-cons y ys*))
       (if (lt? y x)
           (stream-cons y (merge xs ys*))
           (stream-cons x (merge xs* ys))))))
  (stream-let loop ((strms strms))
    (match strms
      ('() stream-null)
      ((list strm) strm)
      ((cons strm strms)
       (merge strm (loop strms))))))</code></pre>

<p>Because the ellipsis form of the <code>seq*</code> pattern is
greedy, it cannot safely be used with streams or other
potentially-infinite data structures without risking divergence. If
this is not a concern, the following alternative definition of the
<code>stream-cons*</code> pattern syntax may also be used.</p>

<pre class="scheme"><code>(define-pattern-syntax stream-cons*
  (syntax-rules ()
    ((_ pat) pat)
    ((_ pat ... tail-pat)
     (seq* strm ((curr strm (stream-cdr strm)))
           (not (stream-pair? strm))
           curr
       (apply stream-car pat) ... tail-pat))))</code></pre>

<p>What cannot be safely accommodated with this pattern matcher is
situations with <code>match-values</code> or
<code>match-lambda</code> where one input value holds information
which, if examined earlier than some other input value, might
prevent the erroneous or divergent forcing of some part of the
other input value. The above example of <code>match-values</code>
in the merge procedure is safe because it must examine both values
anyway, but in general these forms must be used with particular
care in combination with lazy data.</p>
<h3 id="example:views">Views</h3>

<p>The following example of a convenience form for defining new
pattern syntax is based on a design originally by Richard Cobbe and
found in the test suite of Racket’s pattern matcher. It provides a
concise notation for a <code>?</code> test pattern over a series of
<code>apply</code> patterns.</p>

<pre class="scheme"><code>(define-syntax define-view
  (lambda (stx)
    (syntax-case stx ()
      ((_ name test (selector ...))
       (with-syntax (((selector-id ...)
                      (generate-temporaries #'(selector ...))))
         #'(begin
             (define-syntax name (syntax-rules ()))
             (define-pattern-syntax name
               (syntax-rules ()
                 ((_ selector-id ...)
                  (? test
                     (apply selector selector-id) ...))))))))))</code></pre>

<p>The following examples are adapted from those of Wadler
(<a href="#Wadler87b">1987b</a>).</p>

<pre class=
"scheme"><code><i>;; 2 Viewing an integer as zero or a successor</i>

(define (sub1 n) (- n 1))

(define-view zero zero? ())
(define-view succ integer? (sub1))

(define power
  (match-lambda
    ((x (zero)) 1)
    ((x (succ n)) (* x (power x n)))))

(define fib
  (match-lambda
    (((zero)) 0)
    (((succ (zero))) 1)
    (((succ (succ n))) (+ (fib n) (fib (+ n 1))))))

<i>;; 3 Another view of integers</i>

(define (div2 n) (/ n 2))

(define-view even even? (div2))
(define-view odd odd? ((compose sub1 div2)))

(define power
  (match-lambda
    ((x (zero)) 1)
    ((x (even n)) (power (* x x) n))
    ((x (odd n)) (* x (power (* x x) n)))))

<i>;; 4 Viewing a complex number in cartesian and polar coordinates</i>

(define-view cart complex? (real-part imag-part))
(define-view pole complex? (magnitude angle))

(define add
  (match-lambda
    (((cart x y) (cart x* y*))
     (make-rectangular (+ x x*) (+ y y*)))))
(define mult
  (match-lambda
    (((pole r θ) (pole r* θ*))
     (make-polar (* r r*) (+ θ θ*)))))</code></pre>
<h3 id="example:tree-pattern">Tree patterns</h3>

<p>This pattern matcher also does not include by default any
equivalent of the <code>***</code> tree pattern or ‘two-dimensional
ellipsis’ which originated as one of Alex Shinn’s extensions to
Wright’s pattern syntax. The following example shows how a custom
pattern can provide this functionality. Note that this specific
matcher is exactly as limited as the original <code>***</code>
matcher, i.e.&nbsp;it can search only trees based on proper lists
and will never search for the pattern on its right hand side within
the first element of each sublist.</p>

<pre class="scheme"><code>(define-syntax tree (syntax-rules ()))
(define *not-found* (cons '*not-found* '()))
(define (not-found) (values *not-found* #f))
(define (found? x) (not (eq? x *not-found*)))

(define-pattern-syntax tree
  (syntax-rules ()
    ((_ path-pat item-pat)
     (apply (lambda (initial-val)
              (let match-tree ((path '())
                               (val initial-val))
                (match val
                  (item-pat
                   (let ((path (reverse path)))
                     (match path
                       (path-pat
                        (values path val))
                       (_ (not-found)))))
                  ((cons name subvals)
                   (let loop ((more subvals))
                     (match more
                       ((cons subval more)
                        (call-with-values
                            (lambda ()
                              (match-tree (cons name path) subval))
                          (lambda (a b)
                            (if (found? a)
                                (values a b)
                                (loop more)))))
                       ('() (not-found)))))
                  (_ (not-found)))))
            (and (? found?) path-pat)
            item-pat))))</code></pre>

<p>Potential uses of such a pattern include as an alternative to
<a href="https://okmij.org/ftp/Scheme/xml.html#SXPath">Oleg
Kiselyov’s SXPath</a> in some cases:</p>

<pre class=
"scheme"><code>(match '(a (b c) (b d) (c c)) ((tree x 'd) x)) <i>; equivalent to XPath</i>
                                               <i>; //node()[.='d']</i>
<i>;=&gt; (a b)</i>

(match '(a (b c) (b d) (c c)) ((tree (and x (list _ ... 'c)) 'c) x))
                                        <i>; equivalent to XPath</i>
                                        <i>; //c[.='c']</i>
<i>;=&gt; (a c)</i></code></pre>

<p>Note, though, that this pattern has poor performance
characteristics, similar to a naïve string search algorithm. (It is
no worse than Shinn’s implementation in this regard, however, which
uses the exact same algorithm.) A small (non-asymptotic)
performance gain for certain subpatterns would be to use
<code>not</code> to suppress variable bindings the first time the
matcher tries to see if a tree element matches the target pattern.
A pattern matcher with ideal performance on this kind of pattern
would use a completely new approach incompatible with the design
decisions made here to optimize for ‘one-dimensional’ patterns.</p>

<h2 id="design-notes">Design notes</h2>
<h3 id="design-notes:constructor-based-syntax">Constructor-based
syntax and the means of extension</h3>

<p>The question of whether to use constructor-style or datum-style
syntax for deconstruction arose during the pre-R4RS discussion of
pattern matching. Chris Haynes <a href=
"https://groups.csail.mit.edu/mac/ftpdir/scheme-mail/HTML/rrrs-1987/msg00077.html">
presented an early version of his own pattern matching library,</a>
which used datum syntax for pairs and lists, but constructor syntax
for vectors. Jonathan Rees <a href=
"https://groups.csail.mit.edu/mac/ftpdir/scheme-mail/HTML/rrrs-1987/msg00080.html">
pointed out the inconsistency and proposed a resolution,</a> noting
that a consistent constructor-style syntax would allow the pattern
matching syntax to be extended cleanly. He proposed deconstructors
as an extra procedure property on constructors, similar to how the
T <code>setter</code> functionality worked (later specified by
<a href=
"https://srfi.schemers.org/srfi-17/srfi-17.html">SRFI&nbsp;17</a>).</p>

<p>In a subsequent thread covering several questions inherent in
the design of the would-be R4RS pattern matching library, Will
Clinger <a href=
"https://groups.csail.mit.edu/mac/ftpdir/scheme-mail/HTML/rrrs-1987/msg00089.html">
noted the problems of both approaches</a>. Namely, datum-style
deconstructor syntax is, in most cases (including in Wright-style
syntax), not an exact mirror of Scheme’s lexical syntax when
matching of literal symbols is needed, because patterns such as
<code>('x 1 y)</code> do not correspond to the datum syntax of an
actual matching list such as <code>(x 1 "why")</code>; it would, in
any case, be a new sublanguage. (<code>Syntax-rules</code>, of
course, later resolved this with its separate list of literal
identifiers.) The constructor syntax, meanwhile, has a closer
resemblance between pattern matching input (under evaluation,
rather than under <code>read</code>) and individual patterns, but
seemed to pose problems in interaction with the scoping of
identifiers in Scheme code outside of match clauses: what, for
example, is the meaning of <code>list</code> when used as a
deconstructor within a block such as <code>(let ((list vector))
...)</code>?</p>

<p>Under Rees’s proposal for dynamic extensibility, using special
properties on procedure objects, the answer is in fact quite clear:
in that example, <code>list</code> will refer lexically to a
variable which, at run time, contains the same procedure&nbsp;–
including the same deconstructor&nbsp;– as the ordinary Scheme
<code>vector</code> procedure: therefore that procedure will both
(in regular Scheme code) construct, and (on the left-hand side of
match clauses) deconstruct vectors, rather than lists. This seems
intuitive. A similar approach, using properties of OO classes, is
the means of extension for the <code>match</code> statement in
Python 3.10 and above; also, at time of writing, a variant of this
idea using properties of JavaScript functions is part of the
<a href=
"https://github.com/tc39/proposal-pattern-matching">ECMAScript TC39
pattern matching proposal</a>.</p>

<p>On the other hand, research into efficient compilation of
pattern matching has focussed on cases where the semantics of
patterns are completely knowable during ahead-of-time compilation,
which is not always the case when the semantics depend on run-time
procedure calls. If the ECMAScript proposal is adopted, it is
likely that it will lead to more research into techniques for
efficient compilation of patterns when this method of extension is
used, perhaps using JIT-like adaptive optimization techniques, but
this has not happened yet. Moreover, Scheme macros, which are
designed to support full ahead-of-time compilation, may not be an
appropriate tool for implementing this kind of optimization.
Lastly, it is not clear how syntactic operators such as
<code>quote</code> can be used as deconstructors orthogonally to
how procedures are used. Using macros as the means of pattern
extension makes it possible to use optimization techniques that are
already well understood, to implement pattern matching in an
ordinary Scheme macro, and (potentially) to use any Scheme
identifier to signify a deconstructor regardless of the type of its
binding in ordinary code; but it also implies the problem of
conflicting namespaces which Clinger was concerned about.</p>

<p>Queinnec’s original proposal for macro-extensible patterns
seemingly resolved this issue by establishing a new naming
convention for identifiers: his patterns consistently begin with an
<code>*</code> character. Thus, the consistency and extensibility
advantages of ‘constructor-style’ patterns can be retained, but the
use of different identifiers for deconstructors means
deconstruction of values does not exactly mirror construction.
(This might be considered a pro or con, depending on your view of
whether it’s a good thing for identifiers to have context-sensitive
semantics.) <a href=
"https://srfi.schemers.org/srfi-257/srfi-257.html">SRFI&nbsp;257</a>
revives this idea, placing transformers for deconstructors within
Scheme’s single namespace, with a convention of prefixing them with
<code>~</code>. Under this proposal, <code>list</code> and
<code>vector</code>, as ordinary Scheme variables and not pattern
transformers, are simply not allowed as the names of deconstructors
on the left-hand side of a pattern matching clause. The
<code>quote</code> family of operators is an exception to this
naming convention, presumably because of the ergonomic advantage of
being able to use the lexical abbreviations for them.</p>

<p>Identifier properties, used by this SRFI, offer another
approach. In this view, the context-specific semantics of a
constructor identifier have to do with its statically knowable
binding as an identifier, and not with its actual value as a
variable which can only be known at run time. The answer to
Clinger’s question is clear: in <code>(let ((list vector))
...)</code>, the binding of <code>list</code> has been shadowed;
because pattern syntax belongs to bindings and not to values, new
pattern syntax would have to be defined for the <code>list</code>
identifier within the <code>let</code> block, otherwise an attempt
to use <code>list</code> as the name of a deconstructor within that
block would be a syntax violation. This mirrors the semantics of
auxiliary syntax keywords in ordinary, non-extensible Scheme
macros; the set of auxiliary syntax keywords within match clauses
is simply arbitrarily extensible.</p>

<p>Identifier properties, in combination with macros as the means
of extensibility, thus offer the benefits of deconstructor syntax
matching constructor syntax, an extensible set of deconstructors,
and efficient ahead-of-time compilation within an implementation as
an ordinary Scheme macro requiring no special support from the
underlying compiler. While in perverse cases such as Clinger’s
example it is possible that the results of shadowing a
deconstructor’s name may be seen as unintuitive, the semantics in
fact match those already familiar to Scheme programmers from the
use of (auxiliary) syntax keywords in general; in the majority of
cases of shadowing, both the Rees-style dynamic extensibility and
identifier property-based extensibility behave identically,
respecting Scheme’s lexical scoping and its single namespace for
all identifiers in all contexts.</p>

<p>One final approach should be considered, which is that taken by
Racket’s <code>match</code> library. In this view, ‘match
expanders’ are ordinary syntax keywords within Scheme’s single
namespace, defined using a special variant of
<code>define-syntax</code>. By default, the keyword for a custom
match expander may only be used within the left-hand side of a
matching clause, but an optional second transformer may be given
which works as a normal Scheme macro transformer when the
identifier is used outside of a pattern. This allows the same
identifier to be used in both patterns and in normal Scheme code,
but has the disadvantage that an identifier can only be used in
these two specific contexts and can’t be extended by additional
properties which might be used by other embedded sublanguages;
whereas identifier properties intrinsically allow any number of
macros to define and use their own extra information about any
identifier.</p>
<h3 id="design-notes:non-linear-patterns">Non-linear patterns</h3>

<p>Non-linear patterns were first added to a Wright-style pattern
matcher in Bruce Hauman’s PLT Scheme implementation, then copied by
Alex Shinn and Sam Tobin-Hochstadt into their respective
implementations. After thorough consideration, I have decided that
support for such patterns, while perhaps occasionally useful, is a
misfeature in the context of this kind of pattern matcher, because
the composition behaviour of non-linear uses of variables with some
other features offered by this pattern matcher is poor.</p>

<p>Most of the problems ultimately arise, in essence, from the root
issue of deciding which instance of the variable in the pattern
should be considered to bind the single comparand against which
other values which (potentially) match the same pattern variable
can be tested. The intuitive choice is probably the leftmost
instance, but this may in the general case put unenforceable and
equally opaque restrictions on the expansions of pattern
syntax&nbsp;– another feature I find considerably more valuable
than general support for non-linear patterns. In other words,
pattern syntax such as <code>(foo a b)</code> may wish to expand
into a form such as <code>(and (baz b) (bar a))</code> for
performance reasons (note the inversion of variables in the
expansion compared to the original form), but this expansion would
cause the leftmost instances of a non-linear variable within
<code>b</code> to be considered the leftmost overall, rather than
the leftmost instances within <code>a</code> and therefore within
the original source.</p>

<p>While this difference may appear to be abstract in the sense
that all bound values are ‘the same’ anyway, concrete issues arise
in composition with, for example, <code>not</code> patterns. As of
writing, the Racket documentation attempts to explain the behaviour
by saying that ‘instances of an <code>id</code> [i.e.&nbsp;a
variable] in different <code>or</code> and <code>not</code>
sub-patterns are independent’, but this is not entirely correct and
depends on whether the <code>id</code> has appeared outside of a
<code>not</code> or <code>or</code> pattern ‘before’ its appearance
within one. A pattern such as <code>(list a (not a) (not a))</code>
will match a three-item list and require that the second two
elements are distinct from the first (but may be the same as one
another); a pattern such as <code>(cons a (not a))</code> will
match a pair whose car and cdr are distinct. This, at least, seems
intuitively correct. On the other hand, though, a pattern such as
<code>(cons (not a) a)</code> will never match, because the first
<code>a</code> (of <code>(not a)</code>) <em>is</em> considered to
be independent from the second, meaning that <code>(not a)</code>
is effectively <code>(not _)</code>, causing all matches to fail.
To reiterate, if the <code>(cons a b)</code> were for some reason
expanded to <code>(and (? pair?) (apply cdr b) (apply car
a))</code> (note again the inversion of <code>a</code> and
<code>b</code>), the inverse would apply, and <code>(cons (not a)
a)</code> would function as probably expected. The interaction of
pattern syntax with non-linear variables is therefore dependent on
implementation details of each form of pattern syntax. This is not
transparent to the user of pattern syntax.</p>

<p>An informal rule imposed on pattern syntax definitions that
subpatterns should appear in the same order in the expansion as in
the input form may seem sufficient to cure this problem, if one is
willing to accept that the rule cannot actually be enforced by the
pattern expander in any way. Another, more robust solution might be
to require occurrences of variables within <code>or</code> and
<code>not</code> clauses to be truly independent of one another and
of variables outside of <code>or</code> and <code>not</code>, so
that <code>(cons a (not a))</code> would not match any value, or
would simply be disallowed; the pattern would have to be expressed
e.g.&nbsp;<code>(and (cons a b) (not (cons x x)))</code>.</p>

<p>It is also possible that choosing a different set of primitives
to those used in this pattern matcher could help alleviate this
issue. This should be investigated further.</p>

<p>There is another problem, though: non-linear uses of variables
in patterns also compose poorly with ellipsized sequence
subpatterns. Here the problem of choosing which instance to use to
bind the primary comparand compounds with the problem that a
variable appearing within an ellipsized subpattern has (at least)
two semantics. Within the ellipsized subpattern, the variable
conceptually refers to one value within a sequence of related
values; within the body of a matching clause, it refers to a list
of all values in that sequence.<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a> For the purposes of
choosing a comparand for an instance of the variable within the
larger pattern but outside of the ellipsized subpattern, both
Racket’s and Shinn’s <code>match</code> choose the latter
interpretation, but differ in which occurrence of the variable is
used to find the value used as a comparand. Shinn’s implementation
appears to consistently pick the leftmost occurrence, meaning that
patterns such as (the equivalent of) <code>(list x x ...)</code>
match a sequence of identical items of which there must be at least
one, and <code>x</code> is bound to the first item in the list.
Racket, on the other hand, picks the ellipsized instance no matter
where it appears in the list, so that <code>(list x x ...)</code>
matches lists of the form <code>((a ...) a ...)</code> where there
are the same number of equal <code>a</code>s in both the sublist
and the outer list. The behaviour chosen by Shinn may initially
appear more intuitive here, until the patterns are reversed: with a
pattern equivalent to <code>(list x ... x)</code>, it will require
a list of the form <code>(a ... (a ...))</code> (with the same
conditions on the equality and number of <code>a</code>s). Racket’s
version’s behaviour on <em>this</em> pattern is the same as on
Shinn’s, but it issues the warning ‘non-linear pattern used in
<code>match</code>’.</p>

<p class="note"><i role="heading" aria-level="5">Note:</i> I have
not tested the behaviour of both pattern matchers extensively to
determine if the rules listed above, based on observation of a
relatively limited number of test cases, hold for all non-linear
patterns in both versions.</p>

<p>The right thing may be for all non-linear occurrences of an
ellipsized pattern variable to have the opposite meaning as in
Racket: they should refer to one item in the sequence which
matched, rather than the entire sequence. Even this does not fully
solve the problem, if for no other reason than that it makes it
non-trivial to elegantly express a pattern such as <code>(list
(complex-subpattern x) ...)</code> with the additional constraint
that all the <code>x</code>s must be the same. Further, the
performance impact of non-linear patterns in combination with the
repetition operators in sequence subpatterns may be significant.
The full semantic and performance implications of such a change
should be investigated first.</p>

<p>In summary, while it may be possible to find solutions to the
problems of composability of non-linear patterns with other
features of the pattern matcher, the solutions would necessarily
involve significant innovations compared to the semantics of
non-linear patterns in existing Scheme pattern matchers. Finding
the ‘correct’ solutions to these issues, and verifying their
correctness, is outside of the scope of the current version of this
pattern matcher. This version therefore simply does not allow
multiple occurrences of the same variable within a pattern, as with
<code>syntax-rules</code> and <code>syntax-case</code>.</p>

<p>Those interested in more discussion of the semantic issues of
non-linear patterns may find <a href=
"https://www.mail-archive.com/haskell@haskell.org/msg03721.html">this
mailing list thread about the reasons Haskell does not support
them</a> relevant.</p>
<h3 id="design-notes:application-patterns-mv">Application patterns
and multiple values</h3>

<p>The <code>apply</code> pattern syntax does not offer direct
support for checking the number of return values from the procedure
it calls: it is undefined behaviour if the number of values
returned is not the same as the number of subpatterns. Ideally, the
behaviour would be well-defined in this case, namely that the
<code>apply</code> pattern should not match if the procedure
returns the wrong number of values. This would make it easier to
use varying numbers of return values as a cheap kind of sum type,
especially as an option type.</p>

<p>Unfortunately, this would result in a small ‘peanut butter’-type
performance overhead for the vast majority of uses of
<code>apply</code> patterns with procedures which always return the
same number of values: all of these uses would need to compile to
include an explicit check on the number of return values, not only
the uses where alternative clauses check for a different number of
values. Scheme implementations are not very good at optimizing away
such checks (primitively expressed as <code>call-with-values</code>
over <code>case-lambda</code>): as of writing, only Chez Scheme
version 10 is known to be able to do this optimization, and only
for procedures of one return value. It may also make it harder to
keep compile times for optimizing implementations reasonable, since
it would increase the number of primitive pattern types which are
directly refutable on their own terms (and not only refutable on
the basis of some subpattern).</p>

<p>The workaround is to use a procedure argument to the
<code>apply</code> pattern which converts multiple values into a
single container (such as a multiple-value box from <a href=
"https://srfi.schemers.org/srfi-195/srfi-195.html">SRFI&nbsp;195</a>)
and write a pattern checking its contents.</p>

<p>If Scheme implementations’ ability to optimize this case for
procedures of known co-arity improves significantly, then a future
revision of this SRFI may change the semantics of
<code>apply</code> patterns to the correct ones.</p>
<h3 id="design-notes:disjointed-variables">Disjointed
variables</h3>

<p>Disjointed variable is the name I have given to any variable
which occurs in some subpattern(s) of an <code>or</code> pattern
(also formally called a disjunctive pattern, whence the name), but
not in all of the subpatterns.</p>

<p>Here also, the behaviours of the existing pattern matchers
differ. Wright’s original implementation and the Racket pattern
matcher signal an error during expansion upon encountering
<code>or</code> patterns containing any disjointed variables.
Shinn’s implementation binds the disjointed variables to an
unspecified value when the matching subpattern does not contain
them. Hauman’s implementation causes an undefined identifier error
to be signalled when a disjointed variable’s value is accessed and
the matching subpattern does not contain it. Nelson’s
implementation behaves quite strangely and I cannot easily tell
what it is doing.</p>

<p>This pattern matcher takes a slightly new approach: it is not a
syntax error to merely use an <code>or</code> pattern with
disjointed variables, only to subsequently attempt to (statically)
refer to a disjointed variable in the code for the matching clause.
In practice, this is almost indistinguishable from the behaviour of
Wright’s original and the Racket pattern matchers, but with one
difference which is important in the context of macro-extensible
pattern matching: it allows non-hygienic patterns to be used in the
definition of hygienic patterns without ruining the ability of the
hygienic patterns to be used as subpatterns of an <code>or</code>
pattern.</p>

<p>Consider, for example, a pattern <code>regexp</code> which tests
an input string against a regular expression and, as a convenience,
unhygienically binds pattern variables <code>$1</code>,
<code>$2</code>, <code>$3</code> etc. to the substrings which
matched subgroups in the regular expression. A higher-level pattern
<code>correct-looking-string</code> may wish to build on
<code>regexp</code> to create a pattern matching strings having a
certain form, but its use of <code>regexp</code> is purely an
implementation detail that should not be exposed. Fortunately,
syntax object-based expanders already handle this case correctly,
and the <code>$1</code>, <code>$2</code>, <code>$3</code> variables
will be created with marks corresponding to the use of
<code>regexp</code> within <code>correct-looking-string</code>, not
the use of <code>correct-looking-string</code> directly. However,
with the Racket/Wright semantics, any attempt to use
<code>correct-looking-string</code> within only one clause of an
<code>or</code> pattern will cause an immediate syntax error
because of the <code>$1</code>, <code>$2</code>, <code>$3</code>
variables which, due to their marks, are not even accessible within
the matching clause code. Binding these disjointed variables
instead to syntax transformers which always signal a syntax
violation addresses the <em>real</em> problem with disjointed
variables with no run time overhead.</p>

<p>An alternative would be an approach more similar to Hauman’s,
also comparable to the approach used by the <code>letrec</code> and
<code>letrec*</code> forms in case of violations of their
respective restrictions on variable value access and assignment. In
this approach, disjointed variables would instead be bound to
syntax transformers which expand into code signalling a run-time
error if the matching subpattern did not bind the corresponding
variable, and returning the variable’s value otherwise. I think
this would only encourage bad programming styles, though&nbsp;– in
particular, where checks already performed by the matcher are
repeated within the matching code in order to determine if some
variable can be safely accessed&nbsp;– and people should instead
use different matching clauses.</p>
<h3 id="design-notes:coverage-checking">Coverage checking</h3>

<p>The pattern matcher includes no facilities for ensuring
exhaustiveness&nbsp;– that is, statically (at expand time) checking
that a set of patterns covers all possible inputs in a particular
context. Given Scheme’s dynamic typing, full checking of
exhaustiveness is not possible in any case. I considered how to
provide such checking for more limited cases, such as providing
forms that would ensure that all record types within a given family
of related types are handled. Eventually, I rejected this as out of
scope for this library. Tobin-Hochstadt (<a href=
"#TobinHochstadt11">2011</a>) also contains a brief discussion of
the problems of exhaustiveness checking in a dynamically typed
pattern matcher.</p>

<p>Users interested in pattern matching within a closed world of
potential input values may be interested to look at the <a href=
"http://nanopass.org/">Nanopass compiler framework</a> (Sarkar et
al.&nbsp;<a href="#SarkarEtAl05">2005</a>, Sarkar <a href=
"#Sarkar08">2008</a>, Keep <a href="#Keep12">2012</a>) for guidance
and inspiration. Of course, the extensible pattern matcher
presented here may be a good back-end target for a pattern matching
library with this feature, since it already implements the
optimizations needed for good run-time performance. A pattern
matcher with coverage checking may also be able to make good use of
custom pattern syntax within its implementation.</p>

<h2 id="implementation">Implementation</h2>

<p>The sample implementation is provided by the author’s <a href=
"https://codeberg.org/dpk/extensible-match"><code>extensible-match</code></a>
library. Version <code>(- 1 (expt 2 (- n)))</code> is the sample
implementation corresponding to draft <code>n</code> of the SRFI;
when the SRFI is finalized, version 1 will be permanently archived
in the SRFI repository. The implementation should run on any R6RS
implementation with SRFIs 1 (list library), 133 (vectors library),
151 (bitwise operations), 213 (identifier properties), and 244
(<code>define-values</code>), with the additional caveat (as
mentioned under the entry for <code>define-pattern-syntax</code>)
that <code>syntax-rules</code> expressions must return an ordinary
transformer procedure and not any implementation-specific kind of
transformer.<a href="#fn6" class="footnote-ref" id="fnref6" role=
"doc-noteref"><sup>6</sup></a> At time of writing, this amounts
only to Chez Scheme with Aaron Hsu’s <a href=
"https://github.com/arcfide/chez-srfi"><code>chez-srfi</code></a>
package, but I hope to submit a patch to Guile for identifier
property support soon, and Andrew Whatson’s work on porting
Unsyntax (which supports SRFI 213, but does not support much of
R6RS nor the other needed SRFIs) to other Scheme implementations
may also make it available there soon.</p>

<p>The sample implementation is designed to be well-optimizing. On
implementations which support the guaranteed-optimization clause of
the macro-writer’s bill of rights (Dybvig <a href=
"#Dybvig04">2004</a>), the code it produces for any given
<code>match</code> expression should generally be as efficient as
the equivalent hand-written conditionals and bindings.</p>

<p>I would be interested in an alternative, mildly optimizing
implementation in terms of <a href=
"https://srfi.schemers.org/srfi-148/srfi-148.html">SRFI&nbsp;148</a>
which made the means of pattern syntax transformer lookup and
application pluggable. This would allow Scheme implementations
which do not natively provide <code>syntax-case</code> and whose
maintainers don’t wish to provide full identifier property support
to take advantage of macro-extensible pattern matching.</p>
<h3 id="implementation:hints">Hints for implementers</h3>

<p>This section of the SRFI gives hints that might be useful to
anyone coming up with a re-implementation of this pattern
matcher.</p>

<p>The implementation of pattern expansion is quite subtle. Each
individual expansion of pattern syntax must obey the hygiene
condition. In order to achieve this portably, the sample
implementation actually returns to the Scheme expander after each
step of its expansion, so the expander can apply its
marks/colours/timestamps as needed. An implementation targeting a
specific Scheme implementation may be able to do better if it can
access the internals of the expander to actually do identifier
renaming itself, as in e.g.&nbsp;Racket’s <a href=
"https://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-apply-transformer%29%29">
<code>syntax-local-apply-transformer</code></a>. As Ballantyne et
al.&nbsp;(<a href="#BallantyneEtAl20">2020</a>) point out, a system
of primitives such as this would be useful for extensible embedded
languages in general, so a future SRFI should provide a way for a
transformer to re-enter the expander on part of its input without
using CPS-style expansions. A mechanism such as Racket’s <a href=
"https://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._make-syntax-introducer%29%29">
<code>make-syntax-introducer</code></a><a href="#fn7" class=
"footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>
could be a useful primitive for this, which would also provide an
elegant solution to the problems addressed by SRFIs <a href=
"https://srfi.schemers.org/srfi-258/srfi-258.html">258</a> and
<a href=
"https://srfi.schemers.org/srfi-260/srfi-260.html">260</a>.</p>

<p>The test suite for the sample implementation tests publically
exposed behaviour only. It is thus suitable for testing that your
implementation is SRFI-conformant&nbsp;– although the SRFI
specification text is normative, and errors and omissions in the
test suite are possible. The ordering of tests in the test suite is
such that fixing earlier tests is likely to fix numerous later
tests which implicitly depend on the same behaviour as well. See
also the <a href="#entry:match-letrec">note on the test for
<code>match-letrec</code> under that entry.</a></p>

<p>For implementing <code>seq</code> and <code>seq*</code>
patterns, in the general case, you will need to implement a finite
automaton simulation, either using backtracking, an NFA simulation
keeping track of multiple states, or a DFA transformation. For
simple <code>seq</code> patterns you can avoid this. A performant
implementation should probably have multiple strategies on hand
depending on the structure of the <code>seq</code> subpatterns.</p>

<p>There are a number of possible strategies for implementing
<code>seq/unordered</code> patterns. The sample implementation uses
a backtracking approach, which offers near-linear performance for
the majority of patterns. Another option is Brzozowski
derivatives,<a href="#fn8" class="footnote-ref" id="fnref8" role=
"doc-noteref"><sup>8</sup></a> but a naïve implementation will
require exponentially growing time and space for growing numbers of
irrefutable subpatterns, or subpatterns which are ambiguous with
respect to one another. One of the tests in the test suite is
deliberately designed to take a long time (albeit without failing)
on implementations which fail to optimize for the case of a large
number of irrefutable subpatterns. Unfortunately, this test case is
inherently racing against Moore’s law, so if you are using the test
suite 20 years from now, it’s possible it will no longer appear
quite so slow even if your implementation has bad asymptotic
performance.</p>

<p>It is also moderately tricky to statically enforce the ban on
non-linear patterns (which implementations should do, unless they
have solved the problems mentioned in the design notes and have
good semantics for supporting them as a local extension to this
specification). An attempt to use a pattern variable non-linearly
might be local to one subpattern of <code>or</code>, or appear
within a <code>not</code> pattern where binding is suppressed, but
the attempt should nonetheless not be allowed.</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>I stand on the shoulders of the designers and implementers of
many previous Scheme pattern matching forms. Thanks to all of them.
We all collectively stand on the shoulders of the pioneers of
pattern matching in Lisp and in other languages, whose
contributions are described in the rationale and listed in the
bibliography. Thanks in particular to Sam Tobin-Hochstadt, the
author of Racket’s <code>match</code>, and Ryan Culpepper, the
author of Racket’s <code>syntax-parse</code>, and the rest of the
Racket community both for the direct inspiration, and for answering
my questions about the history, design, and implementation of
pattern matching in Racket.</p>

<p>Thanks also to all those who insisted that R7RS Large should
include some kind of pattern matcher, which inspired me to work on
a solution which is (in my opinion) superior to the popular matcher
of Duba, Wright, and Shinn.</p>

<p>Thanks to Stefan Ljungstrand for discussion of possible
features, and to him and also Wolfgang Corcoran-Mathe for working
through the issues with non-linear patterns together with me.</p>

<p>Andrew Whatson pointed me to Frederick McBride’s
Ph.D.&nbsp;dissertation, and to T’s <code>destructure</code>
special form. These were both very useful pointers to help
establish the early history of pattern matching in programming
languages, and in Lisp in particular.</p>

<p>Marc Nieper-Wißkirchen’s <a href=
"https://github.com/scheme-libraries/scheme-libraries/blob/main/lib/scheme-libraries/r7rs.sls">
implementation of R7RS <code>syntax-rules</code> in R6RS</a>
allowed me to review the post-optimization expansion of Alex
Shinn’s <code>match</code> implementation in Chez Scheme, which
helped me identify optimizations to make in my own
implementation.</p>

<p>Jeronimo Pellegrini found an error in an example.</p>

<p>The term ‘subject’ was adopted based on a suggestion made by Ron
Buckton in the context of the ECMAScript TC39 pattern matching
proposal.</p>

<h2 id="references">References</h2>

<p><span id="BallantyneEtAl20">Ballantyne, Michael, King, Alexis,
and Felleisen, Matthias (2020) <a href=
"https://dl.acm.org/doi/abs/10.1145/3428297">‘Macros for
Domain-Specific Languages’</a> in <cite>Proceedings of the ACM on
Programming Languages</cite> <b>4</b> (OOPSLA): 229</span></p>

<p><span id="Burstall69">Burstall, R.&nbsp;M. (1969) <a href=
"https://doi.org/10.1093/comjnl/12.1.41">‘Proving properties of
programs by structural induction’</a> in <cite>The Computer
Journal</cite> <b>12</b> (1): 41–48</span></p>

<p><span id="BurstallEtAl80">Burstall, R.&nbsp;M., MacQueen,
D.&nbsp;B., and Sannella, D.&nbsp;T. (1980) <a href=
"https://doi.org/10.1145/800087.802799">‘Hope: An Experimental
Applicative Language’</a> in <cite>LFP ’80: Proceedings of the 1980
ACM Conference on LISP and Functional Programming</cite>
136–43</span></p>

<p><span id="Dybvig04">Dybvig, R.&nbsp;Kent (2004) <a href=
"https://www.youtube.com/watch?v=LIEX3tUliHw">‘The Guaranteed
Optimization Clause of the Macro-Writer’s Bill of Rights’</a> at
<cite>Daniel P. Friedman: A Celebration</cite> (recorded conference
paper, 3–4 December; <a href=
"https://web.archive.org/web/20050213154650/http://www.cs.indiana.edu/~chaynes/danfest/dyb.pdf">
slides</a>)</span></p>

<p><span>Hauman, Bruce (<i>c</i>2004) <a href=
"http://web.archive.org/web/20070626145722/http://sol.cs.wcu.edu/~bhauman/scheme/pattern.php">
‘Pattern Matching in Scheme’</a> (Internet Archive WayBack Machine,
26 June 2007)</span></p>

<p><span id="HudakEtAl07">Hudak, Paul, Hughes, John, Peyton Jones,
Simon, and Wadler, Philip (2007) <a href=
"https://doi.org/10.1145/1238844.1238856">‘A History of Haskell:
Being Lazy With Class’</a> in <cite>HOPL III: Proceedings of the
Third ACM SIGPLAN Conference on History of Programming
Languages</cite> 12-1&nbsp;– 12-55 (<a href=
"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/history.pdf?from=https://research.microsoft.com/en-us/um/people/simonpj/Papers/history-of-haskell/history.pdf&amp;type=exact">post-print
on the website of Simon Peyton Jones</a>)</span></p>

<p><span id="Keep12">Keep, Andrew W. (2012) <a href=
"http://andykeep.com/pubs/dissertation.pdf">‘A Nanopass Framework
For Commercial Compiler Development’</a> (Ph.D.&nbsp;dissertation,
Indiana University)</span></p>

<p><span id="Landin66">Landin, P.&nbsp;J. (1966) <a href=
"https://doi.org/10.1145/365230.365257">‘The Next 700 Programming
Languages’</a> in <cite>Communications of the ACM</cite> <b>9</b>
(3): 157–66</span></p>

<p><span id="McBride70">McBride, Frederick Valentine (1970)
<a href="https://personal.cis.strath.ac.uk/conor.mcbride/FVMcB-PhD.pdf">
‘Computer Aided Manipulation of Symbols’</a>
(Ph.D.&nbsp;dissertation, Queen’s University of Belfast)</span></p>

<p><span id="McCarthyAndPainter67">McCarthy, John and Painter,
James (1967) <a href=
"https://doi.org/10.1090/psapm/019">‘Correctness of a compiler for
arithmetic expressions’</a> in <cite>Proceedings of Symposia in
Applied Mathematics</cite> <b>19</b> (<cite>Mathematical Aspects of
Computer Science</cite>): 33–41 (<a href=
"http://jmc.stanford.edu/articles/mcpain/mcpain.pdf">post-print on
the website of the author</a>)</span></p>

<p><span id="MacQueenEtAl20">MacQueen, David, Harper, Robert, and
Reppy, John (2020) <a href="https://doi.org/10.1145/3386336">‘The
History of Standard ML’</a> in <cite>Proceedings of the ACM on
Programming Languages</cite> (History of Programming Languages
4)</span></p>

<p><span id="Moses67">Moses, Joel (1967) <a href=
"https://www.softwarepreservation.org/projects/LISP/MIT/MIT-LCS-TR-047-corrected-ocr.pdf">
‘Symbolic Integration’</a> (Ph.D.&nbsp;dissertation, Massachusetts
Institute of Technology)</span></p>

<p><span id="MonnierAndSperber20">Monnier, Stefan and Sperber,
Michael (2020) <a href="https://doi.org/10.1145/3386324">‘Evolution
of Emacs Lisp’</a> in <cite>Proceedings of the ACM on Programming
Languages</cite> (History of Programming Languages 4)</span></p>

<p><span id="Petrofsky01">Petrofsky, Al (2001) <a href=
"https://groups.google.com/g/comp.lang.scheme/c/wyYJ5PwSxSM/m/cZ9Lrj3ROFQJ">
‘How to write seemingly unhygienic macros using syntax-rules’</a>
in <cite>comp.lang.scheme</cite> (Usenet posting, 19
November)</span></p>

<p><span id="PitmanAndMoon89">Pitman, Kent M. and Moon, David
(1989) <a href=
"http://clhs.lisp.se/Issues/iss130_w.htm">‘DESTRUCTURING-BIND’</a>
(memorandum to ANSI committee X3J13)</span></p>

<p><span id="Queinnec90a">Queinnec, Christian (1990a) <a href=
"https://doi.org/10.1007/BFb0024194">‘Compilation of non-linear,
second order patterns on S-expressions’</a> in <cite>Lecture Notes
in Computer Science</cite> <b>456</b> (PILIP 90): 340–57 (<a href=
"https://christian.queinnec.org/PDF/csm.pdf">post-print on the
website of the author</a>)</span></p>

<p><span id="Queinnec90b">Queinnec, Christian (1990b) <cite lang=
"fr">Le Filtrage&nbsp;: une application de (et pour) Lisp</cite>.
Paris: InterÉditions (<a href=
"https://christian.queinnec.org/Books/LeFiltrage.ps.gz">ebook on
the website of the author</a>)</span></p>

<p><span id="Sarkar08">Sarkar, Dipanwita (2008) <a href=
"https://www.proquest.com/openview/b5126e30af6bce9eec3308a0739eb535/1">
‘Nanopass Compiler Instrastructure’</a> (Ph.D.&nbsp;dissertation,
Indiana University)</span></p>

<p><span id="SarkarEtAl05">Sarkar, Dipanwita, Waddell, Oscar, and
Dybvig, R. Kent (2005) <a href=
"https://www.cambridge.org/core/journals/journal-of-functional-programming/article/educational-pearl-a-nanopass-framework-for-compiler-education/1E378B9B451270AF6A155FA0C21C04A3">
‘Educational Pearl: A Nanopass Framework for Compiler
Education’</a> in <cite>Journal of Functional Programming</cite>
<b>15</b> (5): 653–67</span></p>

<p><span id="Shinn06">Shinn, Alex (2006) <a href=
"https://groups.google.com/g/comp.lang.scheme/c/Rc2gH1YJpDA/m/_S8R500jQQkJ">
‘portable hygienic pattern matching’</a> in
<cite>comp.lang.scheme</cite> (Usenet posting, 29
November)</span></p>

<p><span id="SteeleEtAl74-82">Steele, Guy L., Jr., White, Jon L.,
Cannon, Howard I. and Kerns, Bob (1974–82) <a href=
"http://www.avanthar.com/healyzh/_info_/lisp.news">‘LISP.NEWS’</a>
(computer file)</span></p>

<p><span id="Steele84">Steele, Guy L., Jr.&nbsp;(1984) <cite>Common
LISP: The Language</cite> (1st edition) Bedford, Mass., USA:
Digital Press</span></p>

<p><span id="TobinHochstadt11">Tobin-Hochstadt, Sam (2011) <a href=
"https://doi.org/10.48550/arXiv.1106.2578">‘Extensible Pattern
Matching in an Extensible Language’</a> (pre-print)</span></p>

<p><span id="Wadler87a">Wadler, Philip (1987a) <a href=
"https://doi.org/10.1145/24697.24706">‘A critique of Abelson and
Sussman –or– Why calculating is better than scheming’</a> in
<cite>ACM SIGPLAN Notices</cite> <b>22</b> (3): 83–94 (<a href=
"https://homepages.inf.ed.ac.uk/wadler/papers/sigplan-why/sigplan-why-scanned.pdf">post-print
on the website of the author</a>)</span></p>

<p><span id="Wadler87b">Wadler, Philip (1987b) <a href=
"https://doi.org/10.1145/41625.41653">‘Views: A way for pattern
matching to cohabit with data abstraction’</a> in <cite>POPL ’87:
Proceedings of the 14th ACM SIGACT-SIGPLAN Symposium on Principles
of Programming Languages</cite> 307–18 (<a href=
"https://homepages.inf.ed.ac.uk/wadler/papers/view/view.ps">revised
version on the website of the author</a>)</span></p>

<p><span id="Wright94">Wright, Andrew K. (1994) <a href=
"http://web.archive.org/web/20070722125046/http://sol.cs.wcu.edu/~bhauman/scheme/match-chez.ss">
‘Pattern Matching Syntactic Extensions for Scheme’</a> version 1.07
for Chez Scheme (software release)</span></p>

<p><span id="Wright96">Wright, Andrew K. (1996) <a href=
"http://ftp.math.utah.edu/u/ma/hohn/linux/scheme/mzscheme/match.pdf">
‘Pattern Matching for Scheme’</a> (memorandum, Rice
University)</span></p>

<p><span id="WrightAndCartwright97">Wright, Andrew K. and
Cartwright, Robert (1997) <a href=
"https://dl.acm.org/doi/10.1145/239912.239917">‘A Practical Soft
Type System for Scheme’</a> in <cite>ACM Transactions on
Programming Languages and Systems</cite> <b>19</b> (1):
87–152</span></p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr>
<ol>
<li id="fn1">

<p>It is included in the <code>sys/let.t</code> source for T 2.9
(released 1984); the file has a copyright date of
1983–4.&nbsp;<a href="#fnref1" class="footnote-back" role=
"doc-backlink">↩︎</a></p>
</li>
<li id="fn2">

<p>In Tobin-Hochstadt (<a href="#TobinHochstadt11">2011</a>),
Matthias Felleisen claims to have been the original author of this
system, but there is no historical evidence to support his claim,
and some circumstantial evidence against it.&nbsp;<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn3">

<p>The name ‘Wright–Cartwright–Shinn’ originated in <a href=
"https://srfi.schemers.org/srfi-200/srfi-200.html">SRFI 200</a>,
adding the name of Robert Cartwright those of the two people
usually credited with the most widespread implementations of this
pattern matcher. Cartwright did co-author a paper with Wright
(Wright and Cartwright <a href="#WrightAndCartwright97">1997</a>)
which contained an elementary description of the pattern matcher as
a prelude to explaining the use of a subset of its syntax within a
type-inferred implementation of Scheme. There is no evidence that
Cartwright was involved in the design or implementation of the
widely distributed original version of the matcher (running on
standard implementations of Scheme): he was simply a co-author of
another paper with Wright on the subject of a program which
incorporated a version of it. It should have been called the
‘Duba–Wright–Shinn’ pattern matcher, after the three people whose
contributions to the popular implementations of it are
verifiable.&nbsp;<a href="#fnref3" class="footnote-back" role=
"doc-backlink">↩︎</a></p>
</li>
<li id="fn4">

<p>This version still includes a compatibility layer to support
Wright-style patterns, and thus it could be considered yet another
independent re-implementation of Wright’s matcher.&nbsp;<a href=
"#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn5">

<p>If one ellipsized pattern appears within another ellipsized
pattern, it could also refer to a subsequence at any level of
nesting, but this possibility will not be considered
here.&nbsp;<a href="#fnref5" class="footnote-back" role=
"doc-backlink">↩︎</a></p>
</li>
<li id="fn6">

<p>Due to R6RS’s lack of a <code>bound-identifier-hash</code>
procedure, for optimum expansion times with the sample
implementation, the <code>generate-temporaries</code> procedure
should always return identifiers with distinct symbolic names, so
that <code>(symbol-hash (syntax-&gt;datum id))</code> is a
reasonably effective hash function for each <code>id</code> in a
set of generated identifiers.&nbsp;<a href="#fnref6" class=
"footnote-back" role="doc-backlink">↩︎</a></p>
</li>
<li id="fn7">

<p>See also the <a href=
"https://download.racket-lang.org/releases/6.2.1/doc/reference/stxtrans.html?q=make-syntax-introducer#%28def._%28%28quote._~23~25kernel%29._make-syntax-introducer%29%29">
documentation for the previous, mark-based
implementation</a>.&nbsp;<a href="#fnref7" class="footnote-back"
role="doc-backlink">↩︎</a></p>
</li>
<li id="fn8">

<p>The use of Brzozowski derivatives to match disordered sequences
was pioneered by Mark Hopkins in his regular expression library,
and by Joe English and James Clark for SGML/XML validation in the
presence of the DTD/RELAX NG interleaving operator. (See <a href=
"http://www.flightlab.com/~joe/sgml/validate.html">‘How to validate
XML’</a>, <a href="https://relaxng.org/jclark/design.html">‘The
Design of RELAX NG’</a>, and <a href=
"https://relaxng.org/jclark/implement.html">‘Notes on implementing
RELAX NG’</a>) However, both DTDs and RELAX NG put restrictions on
the use of the interleaving operator which make it easy to write a
validator which always runs in linear time (essentially reducing to
a simple anagram problem). Since subpatterns in
<code>seq/unordered</code> can evaluate arbitrary Scheme code, such
a restriction is not possible here.&nbsp;<a href="#fnref8" class=
"footnote-back" role="doc-backlink">↩︎</a></p>
</li>
</ol>
</section>
<hr>

<h2 id="copyright">Copyright</h2>

<p>© 2025 Daphne Preston-Kendal</p>

<p>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the ‘Software’), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice (including
the next paragraph) shall be included in all copies or substantial
portions of the Software.</p>

<p style="background-color: #f6f4d2; padding: 1em;">The software is
provided ‘as is’, without warranty of any kind, express or implied,
including but not limited to the warranties of merchantability,
fitness for a particular purpose and noninfringement. In no event
shall the authors or copyright holders be liable for any claim,
damages or other liability, whether in an action of contract, tort
or otherwise, arising from, out of or in connection with the
software or the use or other dealings in the software.</p>
<hr>
<address>Editor: <a href=
"mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur
A.&nbsp;Gleckler</a></address>
</body>
</html>